hey guys welcome to this Lang chain master class for beginners in this video you're going to learn everything you need to know about Lang chain so that you can start your own AI development journey and by the end of this master class you're going to learn everything that you need to know about Lang chain so that you can go off and create your own rag chat Bots create your own agents and tools and use Lang chain to automate task and even though there's a ton of information in this tutorial I've done my best to make it as beginner friendly as possible you'll see as we go through this tutorial that I've structured everything to start out with the absolute Basics so that we can build up a strong foundation and from there we're going to add in more advanced features and complexities so that you can see what Lane chain is fully capable of and because I want you to get started building your own lane chain projects as fast as possible I've actually included over 20 different examples in this video so that you can just copy my code and start using it in your own projects and to make things even easier I have a link down the description below where you can download all the source code in this video completely for free and it would mean a lot to me if you could hit that like And subscribe button while you're down there too also if you get stuck at all during this tutorial you're in luck because I created a free school Community for AI developers just like you in the community you can go over there and ask questions get support join our weekly free coaching calls and we have over, 1500 different active members in the community so it's a great place for you to meet like-minded AI developers on your development Journey so I definitely recommend checking out it's completely for free and I have a link down the description below below so come over and join the party but enough of that let's go ahead and dive into the rest of the video all right so let's go ahead and cover the outline for this tutorial so that you can understand what you're getting into and so that you can get the most out of this tutorial so to start off the first thing we're going to do is set up the environment on your local computer so that you can run the over 20 different Lang chain examples that I've built for you guys from there we're going to start diving deep into each of the core components of Lang chain so to start off we're going to start working with chat models and this is basically how we're going to start interfacing with you know open AI chat gbt we're going to start working with CLA that's all going to happen in the chat model section and what we're going to do from there is we're going to start working with prompt templates next and this is how we're going to be able to format the inputs that we pass over to our chat models and this is really just helping us build up a good strong foundation so that eventually when we start trying to automate task using our chains which is my favorite part of this whole tutorial we're going to be able to really understand how we can start you know automating task by putting together chat models or prompts and other tasks and really run them all together to automate your workflows from there we're going to start working with rag now this is a huge section of this entire tutorial as you can see we have a ton of different examples in here and if you've heard of people chatting with their PDFs or documents this is what they were doing rag retrieval augmented generation so we're going to do a huge Deep dive into this one and then finally what we're going to do to wrap up this tutorial is we're going to do a deep dive into agents and tools and as you can see we're going to start off with the basics and then we're going to do a deep dive into agents which are are basically just you know chat models however they can make decisions on their own and act it's super cool how it works and then we're going to do a deep dive into tools and tools are how we're going to supercharge our agents to provide them more capabilities so as you can see we have a ton of information in this tutorial so let's go ahead and start diving into the first section which is going to be setting up your local environment so that you can run all the different examples inside of this code base oh real quick I want to mention if you want to get the most out of this video to learn linkchain as quickly as possible here's my recommendation first I recommend watching the video the whole way through on two times speed just so that you can understand all the highlevel Core Concepts of blank chain and then I recommend coming back through this video a second time and just skip to the part that you want to learn about for whatever project you're building for example if you're learning about rag I would definitely recommend just skipping down through the time sense below to watch rewatch the rag section and do a deep dive into the exact part that you want to learn about this is how I go about learning new Concepts so I just want to throw it out to you guys too so you can speed up your development journey and start gilding projects so all right enough of that let's actually go in and start setting up your environment all right guys so it's time for us to start working on setting up our local environment so that we can run all the different examples inside of this project now inside of the read me I have outlined all the different steps that you need to take in order to start running these and it's actually super straightforward so let me just quickly walk you through it to start off we need to install Python and we need to install poetry python I'm sure you know what that is poetry basically if you haven't heard of it before or it's a dependency management tool for python so as you can see we have something called a p project. tommo and this includes all of the different dependencies that we need to install in order to run all the different examples that I've set up for you and poetry makes this super simple to do so what you'll do go over to click this link right here and it will walk you through all the installation steps to install poetry on your local computer and once You' have installed poetry you'll be able to run commands like this so poetry to confirm that it's working and you can see yep poetry is working it's giving me back information and then from there what we can do is once you're inside of your code base and remember all the source code for this project is completely for free just click the link down the description below and you can download it but once you've done that what you can do is type in poetry install D- noout and what it'll do is it'll go through and install all the different dependencies that we saw back over in our py project. Tomo file over here it'll install it and what's awesome is then we can eventually start to run commands like this poetry shell and what this will do is it'll actually spin an interactive shell up that we can see right here it actually has the name of basically our project that we're working on you can see right here it has our name of our project that we're working on and we've created and we can actually start you know running Python and actually start calling all the different example code bases that we have all the different projects so you can see we can do something like python one. chat models and then we can start running you know all of our different code examples so if you got this far you are good to go go for the rest of the course when it comes to python now we just have a few more cleanup things that we need to do first off uh coming back to our read me is I mentioned that you need to update your environment variables so uh when you download the source code you will only see a EnV example file and this is where you're going to instore your environment variables eventually what we're going to do is you are going to rename this file to justv and what this will do is is it'll become your environment variable folder so that whenever you go to run your you know start using open Ai and some of your other different projects they require an open AI key or a Google key or you know all these keys and that's going to get stored to your environment variables I've already have mine set up and we'll be walking through it later but that's the second thing you need to do and actually in addition to that go over to open AI Google fir craw and actually start adding in those open ad keys but we'll talk more about that later on okay all right enough of talking about environment if you've gotten this far everything should be working and we can now move on to actually start playing with the code and Diving deep into L Jing so we're going to go over next and start working with chat models hey guys I meant to show you this quick tip that's going to make coding inside a visual studio code and cursor with python so much easier and solve a big headache that you'll probably have so if you head over to one of your python files you'll notice that you have a bunch of squigglies inside of your project and the reason why is cuz Visual Studio code is not properly hooked up to the new python environment that you just created with all the proper dependencies so here's how we fix that first you're just going to open up a terminal down here and what you'll do is you'll type in poetry shell like we did earlier and this will actually access and you can see yep we're in the right shell but the important part is is it gives us the location of where this basically all of our dependencies were installed so here's where the magic happens you'll come down here and click that you know interpreter path and you'll say enter interpreter path and then you'll just paste in the path you just copied and whenever you do that it'll actually get rid of all the squigglies because now Visual Studio code or cursor is hooked up to your development environment with python so now every time you add a new dependency with poetry ad or whatever you do it will actually you know sync up and you won't have all those random squiggly marks even though you have the Right Packages installed and just as a final note if you ever like well I want to not use this poetry shell environment anymore all you have to do is just type in the word exit and it'll put you back to your base environment so yeah that's a quick crash course on poetry and setting up visual studio code and after that let's dive back into the video all right so it's time for us to dive into our first core component of Lang chain which is going to be chat models now what the heck are chat models and what do they do well a chat model is basically Lang Chain's way of making it super easy for us developers to talk to all the different large language models out there like chat BT claw Gemini and a bunch more they abstract away all the complexity and allow us to basically have conversation ations with these models hints chat and chat models it's all about conversations so what is super nice about Lang chain if we go over to their documentation you can see they have a list of all the models that they currently support now it is very important to mention that for this whole tutorial we're going to be using version 0.2 of Lang chain this is the most upto-date one and a lot of the features and version 0.1 will soon be deprecated uh whenever they upgrade you know probably the next you know five six months from now but enough of that let's dive back into chat models and talk about how we can use them so as you can see looking at chat models here's a huge list of all the different models that we have access to some of these models are better at other things and what's very interesting is chat models inside of Lang chain they provide different functionality such as tool calling outputs you know do they support outputting content in Json are they multimodal such as accepting images and audio so that's what you can see at a high level going over here and what's nice is if you want to work with any of these different models you can just click uh you know use poetry ad and you can type in the name of the package and you'll add it to the environment that you just set up a few seconds ago so let's go ahead and do a deeper dive and look at chat open AI because that's the one we're going to be using mostly inside of this tutorial so if we go over here to chat open aai you can do a deeper dive and look at some of the examples that they already have set up for you so you can see once again they recap what it's capable of doing and then they walk walk you through Yep this is how you can start setting up your files to start using this new package to start chatting with open Ai and eventually down here they dive into showing you y this is how you can start actually using it updating the models and so forth but of there documentation let's go ahead and actually head over to the example that I created for you guys where we're going to start at the absolute Basics and work our way up so you can see what these chat models are capable of so let's come over here start looking at the code and uh take it from here and before we dive into the code on this specific file I just want to give you a quick overview of what you can expect from each of these files so what I'll do in each one of the examples that we're going to run through I will try to provide documentation for you guys up top so you on your own can do a deeper dive into whatever concept we're just learning for example we just talked about chat models and I showed you a link and I also did open AI chat models and we walked through another link so in all the files wherever I point out something you'll be able to go ahead and click those links and a deeper dive on your own if you ever want to learn more about those topics but enough of that let's actually go ahead and start talking about chat models on a basic level all right guys so let's walk through the Three core steps that we need to take to start interacting with our chat models in this case our open AI chat model at a super basic level so the first thing that we're going to do is load our environment variables and if you remember from the beginning we set up aemv file which stored all of our keys to all of the different platforms we were going to access in this case we're trying to work with open AI so it's important that we have an open AI key feel free if you haven't set that up just head over to the open a website go create an account and you'll actually be able to access your open AI key and bring it back and copy and paste it over here now once you have done that what's nice is this load. EnV is going to add all those environment variables so that we can start accessing them in this file and you might be wondering like Brandon what the heck I don't see us accessing the open AI key anywhere well if we actually Peak under the hood inside of the chat model which actually gets imported from linkchain open Ai and that's actually if you head back over to those packages that we had set up earlier that's where it was stored but if you actually hit command on your keyboard if you're on Mac or control if you're on Windows and actually click on it you can actually start looking at the source code under the hood and you can see hey in order to start using this chat model you need to have this API key and we're actually going to start using it if you scroll down a little bit you can actually see under the hood it's actually automatically grabbing this environment key here and unless you pass it in manually and just to like give you guys a full tool you could actually manually pass in your API key here it's just not the safest manner because if you accidentally save your open a key to the public other people could actually grab your API key from GitHub and it's not the most secure so that's why you're going to store everything in your environment variables file okay enough of that let's keep chugging along to actually you know walk all the way through this example the next thing that we're going to do is once we have created our chat model which in this case we're going to say we're using jet gbt 4.0 but we easily could have done something like chat gbt 4 we could have done something like chat gbt for uh you know 3.5 turbo we could have easily changed things up but once we've created that model we can actually St uh start now interacting with it and using it and the key lesson here is we're going to interact with our models in pretty much everything in Lane chain using the do invoke property this is a function that really just whatever we're using it triggers its core functionality so in this case we're working with chat models so it's going to go trigger off like hey open AI or Claud start processing the request I give you but when we're using chains or rag or agents later on everything uses invoke so that's a very key thing to keep in mind as you're working with Lang chain all right so let's just keep walking through what's going on well in our case we're telling our model hey go perform this query for me and we're going to get back a result so let's actually dive into these results so we can see what's happening under the hood and the way we're going to do that is we're going to open up our terminal and let's close it out and give you guys some more space but once again we're going to use poetry shell and this is going to open up that interactive shell that we created earlier which uses you know our new Lang chain crash course environment what we can do is we can actually start calling this function so we're just going to call it Python and this is our chat model so one Tab and it'll go ahead and autocomplete for me and this is the first example so I'll hit one and tab again and it'll autocomplete now I can start running it so let's actually go ahead and press enter and start looking what's happening under the hood so here's what's actually super interesting so you can see we had two print statements one was for the full result and one was content only so for full results you can see that open AI under the hood gives us back a ton of information they give us back the content which is the exact answer we wanted 81 divid by 9 is 9 but then they give us this metadata which is like how many tokens did we use which you know basically why did we finish there's a ton of information which run number was this basically there's a ton of information that they give back to us 99% time you don't care about it however I just want to show you that it is accessible if you ever need to use it so most of the time when you're using you know these chat models the main thing that you want to grab is the content because the content is the example so whenever we grab the result and we access the content property we'll get back the exact string that we usually want to you know show to our users or pull out and pass over to the next prompt in our you know our chat model so that's under the hood how our first basic chat models are going to work so what I would like to do next is we're going to go ahead and move over to the next example where we're going to start actually showing you guys how to do a basic conversation using our chat models to where we can actually like you know pass in more information and actually having a full-on conversation let's go and start working on this example now all right guys so welcome to the second example where we're going to start focusing more on creating a conversation with our chat models now the three new important Concepts to know when going into this example are there are three different types of messages in our case that's going to be a system message and a system message just sets like the broad context for the conversation so these types of messages are usually something like hey you are a professional accountant or hey you are a professional python software engineer help me write this code so that's like just the broad what's going on inside the conversation just the context and then from there there's two different types of messages there are human messages which is us talking to the AI and then there's AI messages which are the AI responding back to us so those are the three types of messages that you can have in a conversation with the AI okay cool now let's dive into the rest of this code so you can kind of see what's happening and this is just once again we're building on our foundation so we're just copying a lot of the code from the previous example and now we're going to start building on top in this case we're going to start creating a conversation so in our case you can see a conversation is nothing more than we have our messages list and our list is just going to store a combination and series of messages in our case we're just GNA um start off with a system message and it's important system messages best practice and I think it's actually enforced a system message must come first and then from there you can alternate human AI human AI but system always comes first because remember this is the context for the conversation as a whole so in our case we're going to say hey solve the math problem and then from there we can pass in a human message and what we would expect to get back is obviously an AI message so let's actually kind of see how we can actually trigger this conversation so we can get a result so in this case you'll see that we have a once again again we have our model our chat gbt model and we're going to call that important function that we talked about in the last one which is invoke but this time we're not going to pass in a you know a hardcoded string like we did over here where you can see we passed in a hardcoded string this time we're actually going to pass in our entire message history and it'll actually read through the entire conversation and then spit out a result if you worked with cat GPT it's exactly like that if you've ever typed into like you know the chbt website it's just like that okay cool so what we're going to do is we're going to go ahead I'm going to comment this out we're going to run the code so we can actually see what answer we get so this time we're going to do python this is you know still working with chat models and this is example two so you can actually see whenever we get an example back with working with chbt it says you know 81 divided by 9 is 9 so you know that's exactly what we would expect to see okay cool but what's nice is we can continue this example and actually have a full-blown conversation so I'll show you what that looks like now so you can see in this second part we actually have continued on the conversation by adding in AI responses and then messages so this case we've added now like the response from the previous one and now we're going to you know just continue adding human messages so I'm just going to run this so you can actually see what's going to happen and this time it's going to come back and give us you know you know 10times 5 so this is completely basic however here's why chat conversations are super important in the real world when you're building your conversations you know it's very common for you to provide an example like hey chat gbt or AI model build me an email it returns a response and then you provide provide feedback cuz remember this is all about conversations and what's going to happen is as you provide those you know feedback of like hey no make it less formal make it a bulleted list you know as you provide that feedback what's nice is going forward in your conversation you can say okay great now do exactly what you did for that last email but now do it for this email and you know storing this message history like you have right here is how you're going to be able to basically make your chat models have awareness in context of what's good and what's bad and what's wrong so this is a very powerful tool and you actually use this a lot more whenever you know you're working on bigger and larger projects but okay cool well now that we have that under the hood and we actually understand like just like basic conversations let's keep it going and actually start working on actually exploring other alternatives for different chat models that we can use because right now we've been focusing on only open AI but let's look at a few different examples of how we can use Lang chain chat models but with different you know llms so let's go ahead and start working on that now all right guys so welcome to this third example where we're going to start exploring different Alternatives of working with other models outside of open AI so in this case we're going to explore Google's Gemini models we're going to look at anthropic or CLA and look at Open Eye because I just want to show you guys how easy Lang chain makes it to work with these different models so let's scroll down so we can look and compare and contrast all the new code so what you can see up top this is exactly what we've been doing so far in all our examples we create our chat model once we have the model we we go off and invoke it and then we get back some sort of result well Lang chain abstracts all the complexity away and makes it super easy to do the same thing with our anthropic models and our Google Gemini models all we do is we instead of using the chat open AI model like we've been doing in the past we now just use chat anthropic and then we can pass in whatever specific model within Cloud that we want to use just like we did with chat gbt up here and then we'll do the normal part where we just you know go off and invoke it with our messages and get back a result and is the exact same thing for Google's giz models down here at the bottom so link chain makes it super easy to work with these different models and this is very important as you build larger projects because certain models are much better at you know at performing certain tasks some are cheaper some are faster so for different situations you need to use different models Lang chain makes it super easy to do and if you want to explore all the different models that each you know anthropic provides and Google provides I have links for you guys and just as a important reminder if you want to go off and explore all all the different chat models back over here in our first example back when we were working with a chat model documentation you could start searching through here so you can explore all the different models and all the different functionalities that these different models provide but okay cool enough of that let's go ahead and start exploring our next example where we're going to be diving in and actually having a conversation with our user through the terminal so let's go and start working on this example now all right guys welcome to the fourth chat model example where we're going to start actually having a realtime conversation with with our AI models this is going to feel just like the chat gbt website except it's running locally on our computer so let's walk through how we're going to set this up so the important part per usual we're going to create our chat model by loading all our environment variables and creating an instance of it now here's where all the interesting part happens because we're having a conversation we're going to create a chat history list and this is going to store all our messages so as we ask questions we're going to add messages to the chat history as the AI responds we're going to add those messages to the chat history and we're just going to continually keep add add in all of our messages to this list so here's how that works in this code example so first off the first message we're going to add is our system message because if you remember system messages are just general context for the conversation that's about to happen so we're going to create that system message and then we're going to add it to our chat history by calling append on the chat history list cool so now here's where all the core logic happens so this is where our chat Loop happens and basically here's the core Loop we first ask our users hey what is the question or prompt that you have for the chat model we're going to get back a query so this is whatever the user passed to us if the user gave us the keyword exit we're just going to stop the conversation right then and there and we're just going to print out the whole chat history however if they didn't give us the keyword exit we're just going to have a full-on conversation so what we're going to do is we're going to add the person's query as a human message and we're going to add it to our chat history then what we're going to do is pass over that entire chat history list over to our model like you can see right here and then we're going to invoke it so that model is going to then read all the messages in our chat history get a response and then we're going to print back that response to our user and we're also going to most importantly track that response by once again updating our chat history so we're going to update our chat history with an AI message cuz you know this is the AI response so enough talk let's go ahead and look at a code example so you guys can see this in action so I'm going to once again open up our terminal and I'm just going to call Python and then this is our chat model project and this is the fourth example so now we can actually start running it and per usual it's now going to ask for query so I'm just going to ask it who are you so then what we'll do is we'll pass that question over to open AI open AI will generate a response and it actually prints it back to us so this is exactly you know if we're talking to chat gbt on their website this is exactly what it feels like and we can actually ask questions about it because as a conversation we can refer to previous messages can you expand on that and what it'll do is it'll you know cuz it can refer back to the previous messages and actually provide additional context so this is super powerful and you'll definitely be using this a lot more and finally we can pass in the word exit it'll quit the conversation and what's cool is you can see our entire message history here so you could save this off somewhere you could you know save it locally save it to the cloud do whatever you want so that whenever the user comes back in the future you can continue the conversation and we'll actually do a much more deeper example later on where we actually save this to the cloud so you'll learn about that in just a little bit all right cool enough of that let's go ahead and start working on our fifth example which is exactly what I was talking about where we're going to start saving our messages to the cloud so let's go ahead and start working on this where we're going to save all of our messages over to Firebase I think you're really going to love this one all right let's go ahead all right guys welcome to the fifth chat model example so this one is by far my favorite because you're going to learn how to save all the messages you type locally over to the cloud and this case we're going to be saving everything to Firebase so what I've done is I've actually typed out all the installation in steps for you guys because there's there's you know a little bit more background setup because we're working with the cloud but once we knock out all the development setup in the cloud what we'll do is just like run through the code so you can see how everything works but I think you'll see that like all in all this is actually pretty straightforward the hard part is just setting everything up in the cloud so let's go ahead and do that now and the first thing I do want to mention about the cloud is this is actually based on this Google fire store codebase example so you can see like this is exactly what we're doing however uh I feel like they didn't do the best job walking through how to get it set up and I struggled a ton the first time I did this so I just want to share all the lessons learned that I have done and and I've copied all my lessons learned here okay so the first thing that you need to do is create a Firebase account so just head over to you know console firebase.com and you're going to create an account and once you've created an account you're going to then go over here and create a project to so I'm not going to like walk through creating a project cuz it's it's super simple but just come over here click the drop- down menu and click create a project so that's how you create a project once you've done that you'll then need to create when you go over to the build tab there's something called the firestore database and this is where we're going to be storing all of our messages inside of our chat history except our chat history is now in the cloud so whenever you click fir store database if it's the first time you're using the project you're going to want to turn this on so there'll just be a turn on button here for you and you'll want to click that and once you've done that and you run the code eventually all of your messages and user sessions will get saved up to the cloud and more on this later but I just want to go ahead and like paint a picture of where we're going fantastic so once you've done that let's heading back to our examples you'll need to start copying some information about your Firebase project so what I mean by that is you need to start copying information such as the project ID so in our case what you'll do come back over here you're going to click the gear icon you'll hit project settings and this is where you'll find your project ID project number and everything that's you know related to what you're what you're doing with the project you just created over here in Firebase Okay cool so that's the easy part now this is where things get a little bit more complicated because we're trying to work with the cloud so Google cloud and we're trying to have our local computer communicate with the cloud so this is where we're going to have to go a little bit deeper so the first thing we're going to have to do is install the Google Cloud command line interface on our computer because what we're trying to do is authenticate our local computer to make requests to the back end that's all we're trying to do so what you'll do is first thing you'll click this link over here and it will take you to this and this will basically just walk you through exactly what you need need to type to install the Google Cloud CLI it's super straightforward you'll just click download once you've downloaded it literally walks you through step by-step how to install it so that's super super easy then once you've gone through and installed everything and initialized it the final part that we're going to do is you need to authenticate your local Google Cloud CLI to your account so once again click this link it'll take you over here and it will just walk you through how you can actually authenticate your local computer to Google Cloud cuz we're just trying to create some default credal that way whenever our codee's running it just can you know seamlessly make a call to the back end and the main things that you need to do first off just run Google Cloud off application default login a signin like normal Google Cloud signin screen will pop up you'll just log in it'll make a service account for you life fantastic and then you'll just run you'll run this basically this script as well to finally get everything working so I hope that's enough I don't want to go too deep just because I want to focus more on Lang chain but run through those steps you guys will be good to go and then you'll find finally have everything working inside your code so all right enough of that here's how we're going to get things working over here so you're now going to come in here uh CU you have your project ID that you just copied you're then going to have a session ID so we're just going to make a new one so we're going to call this user session new on this is where all of our messages are going to be saved and then finally there's a thing called a collection name this is heading back over to Firebase just the way our fir store saves data it's in a collection document basically a database type so you can see collection document collection so it just keeps alternating so we're going to store all of our messages in the chat history collection and each session is going to be a document and that document is just going to contain a list of messages so that's what's about to happen so what we need to do first off is we need to initialize our firestore client and what that's going to do is allow us with our client to go off and make requests so that's why we're doing it and then what we're going to do next is have something called firestore chat message history this is basically we'll just click in here so you can see what's going on but basically what we're trying to do is in the past you and I were storing all of our messages in a list well Lang chain has provided a bunch of different options for us to store all of the different ways that we can have and store our messages so in this case we're using fir store to save our messages there's a few different examples inside of Lang chain where we can actually save our messages using I think the like file message history class where we can actually save all the messages locally on our computer so there's a bunch of different options that I want you guys to be aware of and feel free to explore through the L chain documentation to see other options but just know at its core all it's doing is just saving a list of messages you know human messages AI messages back and forth except now they're just being saved off to somewhere else so that's what's happening under the hood but let's keep going so in our case now that we have basically we've created our new chat history except our new chat history is up in the cloud so what we can do now is actually start running through the exact same Loop that we did last time which is where the human's going to ask a question question and now what we're going to do is just keep adding with our chat history we're just going to add user messages or we're going to add AI messages and we're just going to go back and forth so enough talking let's actually dive into the demo because this is super cool in my opinion so we're going to go step by step because there's a lot of cool ways to show this off so the first thing that we're going to do let's clear this out and we're just going to run python so we're in the chat models example where this is the fifth example now what this will do is it'll start you know initializing firestore client it'll start the chat message history and usually this takes a few seconds to get started and then now we can actually start chatting so it's cool though uh and you'll see this get populated in second our current chat history well because this is the first time I created that new session ID there's no history of this chat in the cloud you know there's no user session d new so there's no messages to load but now I can actually start talking about it so I can say who is Sam Alman so it'll go off and answer questions and you know so here's here's who Sam is but what's super cool is if now if I come back over to the class we can actually see our messages being stored in real time you'll notice they're stored as bite strings and they're not actual just like plain text messages that's just totally fine that's how Firebase and fire store are storing messages but let's keep going does he have a brother so we can keep asking and then it'll say yes he has a brother here's his name and then what we can do is exit it so we'll exit Okay fantastic all of our messages are cleared you can see over over here we actually still have additional messages but what's nice is whenever we restart the same file with the same you know chat session it'll actually say the current chat history and it'll pull all of the different you know messages that we have previously sent to the AI so this is a super cool way and I hope you guys are like this is awesome this is a super cool way for us to continue conversations at a later date without having to completely refresh from start so I hope you guys thought this was awesome because we can still you know do additional stuff like who was I just talking about let me fix this oh sorry wrong button I can say who we just talking about and then because this is a chat history it can refer to the previous messages so yeah this is awesome so I hope you guys are pumped and that concludes the first module where we're just run through all the different capabilities with working with chat models and from here we're going to move on to prompt templates next so I do just want to point out before we keep going if you have any questions definitely hit that link down the description below for school go over there and ask any questions you have or hop on our weekly coaching calls would love to help you guys out but let's keep chugging along and start moving over to prompt templates all right guys welcome to the second module in this Lang chain crash course this whole module is completely dedicated to prompt templates and I think you'll find this is a super simple concept but it's going to make our lives much easier as developers as we work with link chain so what the heck is a prompt template why does it matter how does it work with chat models those are the main things we're going to be tackling in this module so the first thing is prompt templates the best way to think of them is exactly what the name says we are building up a prompt that's our whole goal we're trying to create a prompt but we've created some sort of template like this and it's up to us to pass in values into that template so you know kind of think of like Fillin the blank is the best way to describe it so you know you could do generate three jokes about dogs or something like that is kind of what we're what we're shooting for here so enough like high level let's actually dive into like what this actually looks like in action as like a quick overview and then after this we'll dive into the code okay so like I said our whole goal is we're striving to generate a prompt but we're going to be passing in some variables to make this work so you know we're going to be taking like a user response to help us really fill out this prompt and this is important because eventually these prompts are going to get passed over to our chat models to you know to to perform some action so in our case like this is a joke template So eventually this template once it gets populated it's going to get passed over to you know chbt or Claude one of those models and it's actually going to spit out some jokes for us so that's just this prompt is going to help us structure The Prompt that we pass over so it's super helpful we'll dive into some more examples here in just a second but this is exactly how it works it's up to you as a you know whenever you're creating these prompts to basically create a string and inside that string it's up to you to use these curly brackets to create variables these variables are later going to be populated with these values and what's important to notice here is once we've created our prompt template we're going to Define an input dictionary and this input dictionary is going to Define for each one of these variables the values that are going to replace them because eventually whenever we have our template pass in these inputs and call invoke because remember invoke is the super magic word for all of Lang chain what it's going to do is it's going to basically do some string interpolation and replace all these values so that we end up with an output that looks just like this obviously this was a super simple example but let's just think like higher level like for a real world setting you could eventually be creating some sort of tool that helps developer automatically debug their code well in your case you would create a prompt template that's like here is the user's code and then you know you would have user's code here's the error they're getting that would be the next variable please help them debug this and then basically you would pass in that entire prompt filled with the user's code and error over to open Ai and then open AI would tell you oh it looks like here's a bug here's how it fix it so this is just a really nice way for us to create structured prompts that make it easy you know where we can do some prompt engineering and easily add in our users input to The Prompt templates that we're so uh enough jargon let's actually dive into an example and start walking through our first example working with prompt templates and I think this will make a ton of sense and it'll be super easy to understand all right guys so let's go ahead and dive into the code and this one's going to be a super simple Code walkthrough there's three parts to this and then I have one little extra part so you guys can see you know when not to use prompt templates but let's walk through this part by part just so you understand everything at a basic level and then we'll work our way up from there okay so if you remember our whole goal is we're trying to create prompts that we could eventually pass over to our chat models so we're focusing in on creating prompt templates that's all we're trying to do so let's go part by part in this code and what we're going to be trying to do is trying to relate it back to this outline that we have over here so the first thing we need to do is create a prompt template that stores our variables of things we want to replace so that's exactly what we're doing right here in this code we're creating a template which is just a string and what we're going to do is we're going to call chat prompt template and like well what the heck is this well if you remember at high level we're eventually trying to our end goal is we just talked about chat models that's all we were just talking about in module one well what we're trying to do is create prompts that we could eventually pass over to those chat models so that you know AI can basically answer whatever questions or ask that we're putting together in our prompts so that's our end goal so what this chat prompt template does what it's trying to do is it converts our string into a template that makes it easy to work with to actually replace you know basically replace all these variables with these values so basically what's happening under the hood so once we create this prompt template so once we have our template what we're trying to do is we want to pass in an input dictionary that has all of our keys and values so that's basically exactly what was happening right here and what we're trying to do is once again we're calling that magical word invoke so in this case what's going to happen under the hood is we have this prompt template we're going to call invoke with these specific values and all it's going to do is it's going to go through each variable and replace it with the appropriate value so let's go ahead and run this code so you can see an action so in our case we're going to do python now we're in prompt templates and we're going to run the first example so two one and what this will do is now when I run it what you'll notice is it actually doesn't spit out a string it actually spits out a human message so tell me a joke about cats so that's pretty cool it actually filled in the values that we told it to and if you remember what it did is it spit out basically a messages array that we could eventually pass over to our chat models cuz that's where we're trying to go so that was super simple example one of the other things I want to show you in this is we can actually instead of just replacing one value let's go ahead and look at part two what you'll notice in this one is we can actually replace multiple values in a prompt template so this is the exact same exact same thing except this time what we're doing is replacing multiple values so let's go ahead and yeah we're still calling the same chat prompt template from template so let's go ahead and run the same example again just so you can see it in action so yeah running with multiple placeholders this time tell me a funny story about a panda that's exactly what happens okay enough of the simple examples let's actually get on to some more of the cooler parts which is part three so if you can uh if you've seen so far every time it's created something it has basically been from a human message point of view but sometimes you actually want to do a little bit more you want to have a little bit more control so what you'll notice in part three is we can actually start defining basically we can specify the types of messages we want to create and not only what type of message we want to create we can actually still you know replace all the variables in here and what you might notice and which I thought was weird the first time I used it I would have expected that you know what the heck is this like Tuple where the first part's a simple uh you know the system and then the message then we have another human then message like why aren't we just using like human messages and system messages well it all comes back to the way the chat prop template works is it just expects this tupal format where you define the message type first and then the content so just know if you want to basically use prompt templates and also Define the message type you have to go with this Tuple approach but yeah let's go ahead and see an action so you can see exactly what it looks like so we're running part three so we're just going to run the code again so you can see now we have a list of messages and the first message in this array is going to be a system message and you know you're a comedian who tells jokes about lawyers so that's setting the context and then you can say tell me three jokes so we actually just replace the variables there too so yeah so once again we've created these messages and we could actually pass this message list over to our chat models and it would spit out those jokes about lawyers okay now I just want to show you this is just a lesson learn that I thought was pretty interesting so if we come down here to the final part what you will notice I'm just going to comment this out so you can see it so this code does work so you know how we just talked about tupal well anywhere you want to do string interpolation you know where we're replacing values you have to use the tupal so you'll notice we want to replace Topic in this system's tupal so we have to put it in a tupal and then well for the human message we're not doing any interpolation there so we're just going to leave it how it is so this example would 100% work let's clear it out and I'm just going to show you it works so this one works yep it looks just like we talked about in the first example well if you come down here to the final example that I have in this file you'll notice I say this does not work and basically what we're doing here is we're trying to do interpolation on a human message so let me just show you what happens when you try and like if you don't use a tupal you'll basically get uh you'll basically notice here tell me a joke and it never did the replacing part I ran into a lot of issues when I first started using Lane chain and doing prompt template Replacements and I was like why isn't it replacing it and it's like oh it has to be in this tupal format okay I hopefully um that's enough prompt templates like Basics let's actually start moving on to the next part where we're going to start using actually start using these prompt templates with a chat model in our second example so let's go ahead and start working on that now all right so welcome to the second prompt template example this one we're actually going to tie together everything for module one which is creating our chat models and everything we just learned about prompt templates so let's go ahead and merge both these together in the example so you'll actually really understand the whole value of creating these different prompt templates okay so per usual like we did in all of module one we're going to load our environment variables and we're going to go ahead and create a chat model that's using open AI in this case now let's go part by part so you can actually see the exact same basically all the prompt templates that we created in demo part one we're actually now just going to like not only create those prompt templates but we're actually going to pass over those prompts to our model so let's look at example one in depth and then we'll just run it you know for everything else so per usual uh we're going to create our template with the variable we want to replace once we have that string template we're going to call chat prompt template and we're going to make an actual template from that string just so it's easy for Lang chain to actually start manipulating it and from there we're going to do exactly what we did last time which is call invoke cuz that's the magic word for our prompt templates to take in that string and actually start replacing all the values so once we call invoke we're going to get back that prompt and what's cool is we can now pass that prompt which is if you remember from the last one it's now just going to be a message array that has all these values in here so you know it'll say tummy joke about cat and that'll be one of the messages one of a messages in our message history that we're going to pass to our model I hope that makes sense um you whenever I run it it'll actually make more sense so um but what you can see is we're now going to pass that prompt over to our model and we're going to tell our model invoke because we want our model to actually like perform actions on these messages and we're going to print the result so you'll start to see you know invoke is going to get called a lot as you start to work with Lane chain more and more and I'm not going to go too deep in part two and part three because we just copied and pasted over all the examples from the last time and now we're just actually going to see let AI actually run basically run the request which is creating jokes about all these different prompts we've created so what we're going to do call python example two and this is the second example for prompt templates with a chat model let's go ahead and run that and this will take a few different examples seconds but you can see so prompt template prompt from a single template which was right here tell me a joke about cats so you know sure here's a joke about cats for you why was the cat sitting on the computer because I wanted to keep an eye on the mouse so obviously they're pretty corny and same with multiple placeholders so it actually told a short story about you know a short funny story about pandas so here's our funny short story and then finally when it comes to the end where we're doing you know prompts with system and human messages what we're doing is creating three jokes about lawyers and that's exactly what it did here are your three lawyer jokes so why don't sh sharks attack lawyers because of professional courtesy so once again pretty corny but um yeah so I wanted you guys to see prompts with prompt templates because right now we're calling invoke to get the prompt we're calling invoke again to get the result which leads us perfectly to chains because this is exactly what we're about to do next where we're actually like technically we're chaining prompts with chat models so this will make more sense so we set ourselves up perfectly to get to dive into section three which is all about change so let's go ahead and start diving into that model now and this will all make sense and it'll actually be a lot simpler so you'll see what I mean in just a second all right guys so welcome to the third module in this Lane chain crash course this chain section is by far my favorite part of the whole tutorial and I hope you guys love it just as much as I do so let's walk through what the heck is a chain why is it important and then just go through a few different examples real quick and then we'll hop over to the code okay so at a high level what the heck is a chain well inside a lane chain it's nothing more than tying together a series of task so if you remember so far we've been using invoke the invoke function a lot so we've been using it to create prompts we've been using it to basically have chat models respond to us so what what we could do instead is have the prompt be chained like the output of a prompt whenever we invoke it that output be fed to the model and then that model whenever we call it invoke again it will spit its outputs and it could just go to the next item so as you can see we're kind of just chaining together different task and we're passing the input from the first one over to the next one and we just keep going down and down and down so that's exactly what's happening right here have a prompt invoke it spit the outputs over to the next thing Tak in those inputs process it with invoke and then spit it out to the next thing so that's exactly what's happening with chains and I think you'll think when you see the code it's super simple and there's another common thing when you're using using chains inside of Lang chain and it's called Lang chain expression language it's a fancy way to say and describe like how you can create chains cuz you can go the hardcore code way which we're not going to get into we're going to stick to this which is just anytime you want to chain items together in L chain you're going to use the pipe operator so this is like right above your return key on your keyboard it's just the straight up and down basically pipe key so that's how you're going to create a chain you're just going to put you know a prompt a chat model and there's a few other things you could put in here too but this is how you're going to do it item or a task a pipe operator another task a pipe operator another task super easy to set up and then whenever you want to run the chain all you do is you call the chain and you call invoke on it and then you pass in your input dictionary of all your different keys and values this actually should be a quick uh my bad this should just be a quick dictionary just like this and that's how it works so this initial key dictionary gets passed in over here as the first into the first prompt then it gets passed along all the way through so that's just at a high level just a simple chain now let's just I just want to show you the realm of the possibilities when it comes to Lang chain first and then we'll hop into the code okay so when it comes to chain possibilities the first thing to know is like you don't have to do just prompt chat model you can actually keep going so you can just continually keep going as long as you want that's option one the other thing that's super cool is you can run task in parallel so you can have task you know just like oh kick off kick off and you can just start running your chains in parallel and then you can actually even at the end of them you can actually join them together and have your final results all come back and be fed into one so this is a cool way just to like if you need to do some parallel processing this is a cool way to do that the final thing is branching so branching is a way inside of your chains to have it to go like let's you know at this node let's kick off some actions cool well based on the results of those actions let's just say like oh it's um if we're doing a review of a movie well if the movie was good cool we're going to go down this branch and this chain path if the movie was awful we're going to go down this path and if it was so so we're going to go down path C so that's just kind of like the realm of the possibility when it comes to chains but enough like theoretical highle stuff let's actually dive into the code and start working on the simple model first and then we'll work our way up through all the different possibilities so let's go ahead and dive into the code all right everybody Welcome to the first code example when it comes to chains I think once you see how this all works you're going to be like oh my gosh this is so much easier than what we were doing beforehand and what's cool is we're going to use basically the same examples that we did from beforehand but just reformat them so they work with chains so let's go ahead and dive through this and walk through it step by step so the first thing that you notice we're in the chain Basics file what we're going to do is exactly what we've been doing so far with everything else we're going to create our chat model once we create our chap model we're going to create our prompt template our prompt template is going to contain our variables that we want to replace in this case it's going to be the topic and the joke count from there what we're going to do is create our chain now what you'll notice this is very similar to to the drawings I just created a few seconds ago the first thing we're going to do is have our prompt template which is going to contain all the messages that we want to basically replace with our inputs later on create our prompt from there we're going to pass that prompt to our model once our model then has basically is able to process that prompt what we're going to do eventually is spit everything out to a string parser at first I'm going to get rid of this string parser just so you can see why we need it but just know at a high level all it does is it takes you know how so far every time we get the result we do do content well that's exactly what the string parser does for us it just goes ahead and grab the content but we'll we'll add it back in in a little bit so comment it out just so you guys can see it how it works okay cool so what I'm going to do is go ahead and run this chain just so you guys can see how easy it works and how simple it is how much less code we're doing in this approach versus what we were doing last time so what I'm going to do ahead is go ahead and open up our terminal and then if you remember now we're in the third module cuz we're working with chains and this is the basic example so we're just going to run python three so we can go open our chain file and this is the first example and what I would expect to see is once we print the result we're going to get that long response that we normally get whenever we don't grab the content so you can see yep here are whenever we look at the content you can see yep here's the three lawyer jokes and then we're seeing all that extra information that we get back from our LM like tokens and so forth but if we undo our changes earlier and just use the string parser that you can see right here where we're just doing the string output parser this also comes from we'll talk about this more but the output parser Library that's where it's coming from but if we rerun it now what you'll notice is it actually just spits out the final text like this is what we would actually expect to return to our customers if this was a web app or you know this is what we would like most likely pass to the next model if we were doing this you know and continuing the chain so this is awesome I hope you guys see how much easier this is to use compared to what we were doing last time i' actually let's just do a side by side so you guys can kind of see exactly what this looks like so over here what we were doing yeah at the bottom we had our you know we created our prompt templates then we did our prompt then we invoked it then after we were done invoking it we saved the result then passed it to our model then did it again and again so all of this code right here basically uh just gets replaced with this single one line which is beautiful so I hope you guys like this so now that we understand the basics what I want to do is we're going to dive deep for a second in the next example where we're going to understand how chains work under the hood and after we do that we're going to start building off those examples you saw earlier where we're going to do you know pillow chains and then branching and much more so let's go ahead and dive into the next example all right so welcome to the second example in the chains module and in this example what we're going to do is a deep dive into how chains work under the hood now this isn't super important for you to like memorize or understand exactly how everything works under the hood it's just I want you to be aware of a few Concepts such as runnable sequences runnables and runnable lambdas those are the main three things that we're going to talk about in this section okay so let's dive into the code and we'll look around so per usual what we're doing is we're creating our models and loading our environment variables creating our prompts and then most of the new action when it comes to creating basically chains the manual way happens right here so what we're going to do is talk about this at a high level and then we're going to dive into each part so at a high level what we're doing is we are creating runnable lambdas so think of a runnable is a task whenever I was talking about task in the initial outline for chains under the hood the way it actually works in Lane chain is it's just called a runnable so what we're doing a runnable Lambda is nothing more than a task that's a Lambda function and if you're newer to python don't worry about this Lambda functions kind of get like a little bit more into weeds but they're just a quick way to make functions so like here's the input to a function and then here's the actions we want to take so that's just kind of what Lambda functions are so that's part one part two is this thing called a runnable sequence and a runnable sequence is nothing more than we're going to do this task then this task and this task then this task and put all those tasks together you have a sequence AKA a runable sequence AKA a chain so that's exactly what's happening so let's actually dive in deeper into these runnable lambdas and runnable sequence so you can actually see what the heck's going on so the first thing is what we're going to do is we're going to create the format prompt runnable Lambda and what this is going to do is all it's going to do is take in our prompt template that we've done in the past and then instead of calling invoke on it what we're going to do is just call the format prompt and the format prompt is basically just going to like yep replace all these you know values right here with these values down here so that's exactly what's happening under the hood and you can see we are passing all of our arguments and spreading them right here that's exactly what that's doing basically we're just passing this dictionary and spreading it so that we can replace all these key values with these values down here so that's what's happening don't have to understand how it works exactly I just I just want you to be aware of like what's happening from there once we have our prompt and we've created that task we're going to create an invoke model task and the whole point of this runnable Lambda once again just a task that takes in a Lambda function all this is going to do is it's going to say yep we have a model we're going to invoke the model and what we're going to do is pass in a you know pass in the input from the previous function into this one and we're going to convert whatever the heck we just received to messages so that's what's exactly happening there finally we're going to parse the output so if you remember the string output parser well under the hood all it's doing was grabbing the content from the output and that's what we're going to do right here so here's how now that we have all these individual runnables here's how it works with a sequence and let me just show you under the hood what a sequence looks like so um just in case you haven't seen this if you have a Mac you can hit command and click basically any any class and it'll take you to the definition if you have a Windows just hit control and then click the the class and it'll take you to the basically the the definition but basically this is recapping everything that we have just talked about you know a runnable is nothing more than just like it takes the output from one passes it to the next as an input so just we really just creating a sequence of task that need to occur they give us a cool little example just to show us like yes whenever we use Lang chain expression language to where we just like pipe task and runnables together it's actually the same thing as you know calling runnable sequence first and last and then once you have a sequence you can invoke it and pass items into it so that's what's happening under the hood so let's actually hop back to our code example and finish this one up real quick so we can actually keep keep going down the chain what you'll notice is whenever I created my runnable sequence you'll have three different properties that you can call and this is because if you scroll down to the actual code part you can see there's three different things there's first middle and last first is a single run last is a single runable and middle is a list so that's just how you have to pass in your sequence so if you have two items you'll call first and last if you have five items 10 items 100 you know you'll have to call first for the first item last for the 100th and everything in between will just get passed in as a list so that's exactly what's happening so in our case the format prompt where we convert our text over to a prompt happens as the first task our middle task where we have our formatted prompt and pass it to to our model so we can actually process it that gets passed in the middle list and then finally for the last thing once we you know have our prompt pass it to our model process it in Ai and we just want to get that final text output well that's why we're going to call the last runnable task which is just going to be Parts output and when you put all that together you end up getting a chain and that chain is exactly we'll call it the exact same way that we were doing earlier so what I'm going to do I'm going to run the code real fast just so you can see how it works and then I'm going to compare them side by side just so you can see like that's crazy that they do the same thing but this just takes so much more work cuz we're not using the L chain expression language so this is chains under the hood so we're going to run it and as you can see whenever it finally gets done it's just going to spit out a response which is you know just three jokes about lawyers so yeah that's just that's three different jokes and just to show you a quick side by side let's go open up three one chain Basics and zoom out yeah so instead of doing all this nonsense where we're creating runnable lambdas and passing stuff over and over and creating runable sequence just stick to L chain expression language and it just works so I hope you guys Now understand why L chain expression language is so nice and that's probably what you'll use 99% of the time whenever you're working with building chains but enough of that going deep let's actually hop back up and start working on some of the additional ways we can use chains so we're going to broaden them out in the extended section and then we'll keep moving on from there so let's go ahead and hop over to part number three all right guys so welcome to the third example in the chain module and in this example we're going to Showcase how you can continually extend your chains and add on additional runnables or probably the easier way to think of it is additional task to continually happen and you can just keep growing that chain forever so let's just go ahead and look at the code in this example so you can see how it actually works so what we're going to do is the per usual where we're going to load our environment variables then we're going to create our model and then we're going to create our prompt that's all the usual stuff all of the new chain extending has happens right here where we're going to uppercase the output and then we're going to count Words so let's actually dive into what's happening well what we're going to notice is we're creating our usual chain and then we've piped in an uppercase output well under the hood when we actually look at what's going on in this function because it is important whenever you extend or add new items to your chain by doing the pipe operator you need to add runnables that was one of the key things we talked about in the under the hood section so in this case we're going to add a run Lambda and runnable lambdas just make it super easy to like basically process any type of function so in our case we're just going to do some like string manipulation where we're going to Upper C like sorry I I'll slow down for you guys but like we're going to take in an input and what we're going to do is call uper on it which is going to capitalize the entire output so that's what's happening under the hood but what's cool with runnable Lambda functions is you could also use these to go off and make like an API call you could you know you could really do anything that you normally could do with python code you could just throw it in a runnable Lambda function so that's the part that makes this really cool but so now that we have uppercased the output what we're going to do is continue building on our chain and we're going to pipe the output of this over to count words so in this case when we come look at our count Words runnable Lambda you can see we're going to taking an input this input is going to return basically a string that we're going to do some interpolation on which basically just means some like formatting and passing in values so the first thing we're going to do is count the word count so what you can see is we're going to split the input that's given to us and then once we're done with that we're going to count count how long the actual input was and then once we're done with that we're just going to spit out like right here it just says you know curly brackets X that's where we're just going to print out the input that was given to us enough talk let's actually dive in so you can look at what actually happens under the hood when we actually run this so this is the third module for chains this is the third example and when we spit it out we would expect to see the word count yep just like that and then jokes so as you can see this code ran perfectly we spit out the output and you can actually see that this code ran too because everything is capitalized where it wasn't originally so this is how you can continually build chains and as you're going off and becoming you know a real world professional L chain developer some of the other practical things you would do is just like I said you would use runnable lambdas to go off and like create API calls to go do something you would then there's just a ton of stuff that you could do and chains make it super easy to you know pipe an input from the previous result over to your current function and just continue going down the chain so this is awesome so now that we've covered extending and continually growing your chain let's hop over to talk about how you can actually run chains in parallel I think you're really going to like this section too all right guys so welcome to the fourth example in the chain module in this code what we're going to be doing is showing off how you can run chains in parallel so I think this one's super cool cuz if you've ever thought about creating social media posts where you have like an idea and then you want to like Branch off to write something on LinkedIn and then Twitter and then elsewhere this is exactly how you're going to go about doing it so let's go ahead and dive into the code at a high level and then I have a visual for you guys just cuz it is it is a little bit weirder to see how it all works and then we'll come back to the code to like really dive in okay so at a high level this file is a little bit longer and I'm just going to hop down to the chain part and then from there we're going to go over to the visual I was just talking about so at a high level what you can do is you can see we are creating a chain this chain has the usual prompt has a model we do some string outputting and then we start doing this funny thing called runnable parallel under the hood basically what this is doing is it's creating different branches to run you know if we're looking at Pros cuz this is going to be a pro con list and we're just going to run run our Pros in one chain and we're going to run our cons in another chain and eventually merge those Pro cons into a final list so that's why we have two branches one for pro a pro branch and then a con branch and that's where they're going to go off and generate pros and cons and we're going to come back and put into a final list so that was high level just talking through the code so let's hop back over to what this looks like under the hood when we're actually like you know visually what does this look like so that chain that we were just looking at what we're going to do is it's going to take in a prompt this prompt is going to take in a product name from there it's going to construct a prompt using in our case I think we're going to do the MacBook Pro and then from there it's up to the model to produce a list of features about that product from there we're going to grab the content like we normally do from the result from the model and just pull out the content string and what's cool is we're going to pass that string to our two separate chains so I don't know if you saw back over a second ago but we had a pro chain and a con chain that's exactly what we're doing here so the pros it's going to take in you know the list of features and in our case we're going to pull out all the pros from those features and then what we're going to do on the other side in parallel is find all the cons for all those features and then finally once we're done with both of those different chains that are running in parallel we're going to grab both of the outputs and then put them together in a final Lambda runnable so we're going to get both of those outputs and then put them in a basically a nice print statement for our users to read pretty easily so that's exactly what we're doing now let's hop back to the code and do a deeper dive now you have a good understanding of like what's happening at a super high level visually all right let's hop back okay let's dive into this part by part and I think the best way to go about it is just start you know at the first item in each chain and then walk our way through so when it comes to the prompt template this is where we're going to be doing our normal prompt template stuff meaning you know we're just going to say like hey you're an expert on doing product reviews and I need you to basically list the main features for this product we're going to create a prompt for it in our case like I said this is going to be a MacBook Pro and then we're going to pass that prompt over to our model who's going to go off and actually list those features out then we're going to do our string output parser none of this should be new so far but then we're going to hop into this runnable parallel basically you know runnables are how chains work under the hood so in this case we're doing parallel meaning we have a bunch of branches that we can spin off our different chains so in in this case we're going to have a pro branch and a cons branch and you can actually dive in and see what each one of these these are so this Pros Branch under the hood it's a runnable Lambda and what we're doing is we're actually just creating in our case we're creating a new chain right here that's exactly what it is I can actually rename it for you guys so you can actually see exactly what it is we'll call this one a chain that one a chain perfect just so it makes a lot more sense and it's even more clear what's actually happening so we're creating a chain for our prob branch in this case we're saying like hey take in the input which in this case is a feature list I want you to analyze those probes so analyze Pros all it does is it creates a new prompt template just like we normally do and once we have that prompt template what we do is we pass that prompt template over to our model for our model to go off and generate those pros and then finally per usual we use the string output parser to convert that output into a nice string and the con branch is the exact same thing we take in that list of features about our product we pass that list of features over to this prompt template so you know given these features list the cons of each one of those features from there pass it over to our model string output so all this is completely normal we've done this a ton of times now here's what's different after we run our parallel branches what we end up with is actually one big dictionary and that dictionary if we'll print it out I'll print it out for you guys so you can actually see what I'm talking about right here so we'll say final output what you can see is it'll actually include something called branches and this branches will under the hood actually list out our pros and cons cuz that's how we're going to save them and you'll see it in a second whenever I print it out but that's the final part what we're going to do is pass in our Pro output and our con output into this combined Pros con function and what this is going to do is just print out a nice list string final output for us so we can compare like yep should we get the Mac should we not get the Mac so let's run it and actually dive into the outputs so let's come down here let's clear all old outputs up and start running it now what's going to do under the hood like I said it's going to start running and the first print output we should see is this final output right here where we're going to have our Pros chain and our cons chain we're going to be able to view both of them that's what's going to happen in here and then finally afterwards we should expect another final output I just want to show you guys under the hood how the inputs are getting passed into this and how we can actually view like yeah it does make sense that we need to grab the Branch's object and then within the Branch's object we need to grab the pros and cons so let's scroll up so you guys can see exactly what I'm talking about takes a few seconds Okay cool so here's where everything's in a dictionary that's why it's all cluttered to see but you can see final output what it does you can see it's a dictionary inside the dictionary you can see the first object inside of it is called branches and then within branches we can grab pros and then if you scroll down a little bit later you can also see cons if I just search for it you'll be able to see it cons let's see yeah so you can see here's the cons object so how does this actually work under the hood well it's because everything in this runnable parallel is equal to we basically created a dictionary right here because you can see we have branches is equal to and then we're creating our object so Pros are going to be saved as the result of this Pro chain and cons are going to come from this Con chain so that's exactly how it works so I hope that makes sense once again this is getting a little bit deeper into the weeds when it comes to working with Lane chain and we're starting to do a little bit more like fanciness with python so if you have any questions on any of this please definitely go over to the school community that I've created for you guys drop a comment you know take a screenshot of what's con confusing you and I'd be happy to help or hop on our weekly coaching calls but I hope you guys see the value in this because in the past you would have had to run your Pros chain that would have taken 30 seconds then you had to run your cons chain that would take another 30 seconds but now when we can run stuff in parallel we can cut it down and make things a lot more efficient if you're going to be building applications for your users where they're expecting a speedy output this is exactly what you're going to want to do to help automate and speed up some of your task all right so enough of talking about running chains in parallel let's go over to learning how we can start branching our chains based on different conditions let's go ahead and dive into task numberb five next see y all right guys so welcome to the fifth example in the chain module and this final example what we're going to do is cover branching and I think the best way to cover this topic before diving into the code is to actually look at what this code looks like visually so let's hop back over here to excal draw and let me run you through what's actually happening under the hood so there are two parts to this chain the first part is what we're going to call the classification chain and what we're trying to do is we're trying to take in feedback from our customers so they're going to say like man that was awesome or like oh that was the worst product I ever bought and depending on what type of feedback they give us we're going to have different prompts to generate different types of messages so we're going to have a positive Branch we're going to have a negative Branch a neutral branch and then if something goes wrong we're going to have an escalation Branch so here's a quick run through of what's Happening visually and then we'll hop back over to the code so visually what we're going to do is do the normal chain for our classification where we're going to have have a feedback prompt what we're going to do is in this prompt we're obviously going to populate the prompt with the user's input in this case it's going to be their feedback about what we're doing then we're going to categorize that feedback into one of you know one of these four keywords positive neutral negative or escalate so that's how we're going to basically classify everything then we're going to pull out the category with a string parser like we've done a ton of times by now and here's where the New Concept comes in we're going to it's going to be called a runnable brand and basically the way this works is it's think of it as like an if statement so if the you know if a conditions met we're going to run a different chain so this is a really good way to like really you know make your chains more intelligent and in different scenarios run different chains so in this case just you know going deeper we're going to check if the category was positive if it was fantastic we're going to run the positive chain was it negative cool we'll run the negative chain so forth and so forth so I hope this all makes sense now let's hop back over to the code so you can see what this actually look looks like inside of Lang chain all right so welcome back to the code and I think what you'll notice is this is going to be super straightforward so what we have to start is we have a bunch of different prompt templates each one of these prompt templates for positive feedback negative feedback neutral feedback and escalate feedback all these different prop templates come from right here so as you can see across the board we have all these different prompts that's what we're doing we're building up each one of these chains for the different types of feedback all right let's keep going then eventually what we're going to do is we also need to create the prompts for our classification part so this is you know how you know your helpful assistant help us classify the sentiment of this feedback is it positive negative neutral or do we need to escalate it and this is how we're you know using our prompts to pass in our users feedback cool so here's where we're going to get into the new part which is the runnable branch so this is the part that is different than anything you've seen so far so what you're going to do is you're going to create a runnable branch and the synopsis of how this works is you're going to have a input so in this case we're just going to use a Lambda function and then you have a conditional right here so in this case we're going to say like hey is the word positive in the input that you just gave me if so fantastic I'm going to run and this is basically oops sorry this is basically the positive chain I'll just write right here back chain fantastic so this is actually what's happening under the hood we didn't full out you know call each one of these their own chains but each one of these is a neutral chain a positive chain and a negative chain so here's you know this because this is once again we're using Lane chain expression language to create a positive chain so as you can see we're just going to take in the promp template that we saw above we're going to pass that to a model and then we're going to get back the output so this is a message that we could respond to our users saying like oh you loved our product fantastic I really appreciate it and we hope you you know continue to buy further products and services from us okay so now you've kind of seen how we're going to use runnable branches to conditionally run different chain such as positive chains check to see if it's negative to run the negative chain see if it's neutral to run the negative chain the other part that I haven't mentioned yet is there's a default so when you're using runnable branches if any of these messages didn't trigger off like if we didn't run you know the positive negative or neutral you basically can create a default branch and in this case we're going to call it the escalate branch and what this one's going to do is it's actually just going to make a nice message for us that we can see where it's going to like hey generate a message to escalate this to a human agent so that's just kind of how it works and this could definitely be super helpful in a customer service type of situation so I just wanted to show you guys this cuz it's super helpful and helps you build more complex tools all right so now that we got the runnable branches out of the way let's go back to see how we can make this work so basically in the end we're going to have our classification chain and then you know which is just going to be this whole part right here this is the entire classification chain right here and then the entire bottom part all of this huge square right here is going to be this second chain so we're chaining chains together to make super long complicated ones I hope you guys like this all right so what we're going to do next is I'm just going to go ahead and run it so you guys can see the results and if you want to play around with this code for yourself what you'll notice is I went ahead and typed up a bunch of different types of reviews so you can experiment with each of the different branch pths so let's go ahead and run it for a positive review fast just so you can see you know how it works so we're just going to go open up our terminal and this time what we're going to do we're going to do Python and this is the third module so chains five to run this branching program so we're going to run it and what we would expect to happen is it to ex to go down the positive branching path and generate a nice positive message so you can see you know I hope this finds you well I just want to personally thank you for your positive feedback so you can see it's actually it's actually working and what we could do too if you want to try out something different let's try out a bad review just so you can kind of see how it would go down the in this case go down the negative branching path so I replaced it with the negative comment it's terrible I broke it after just one use and then you can run it again so let's see you know thank you for your feedback I'm sorry that your experience was not up to your expectations we take all this feedback so as you can see this is a way we can handle a bunch of different scenarios using GL chain expression so yeah that concludes the third module where we're covering chains and what we're going to do next is move over to rag which is going to be what we're learning about retrieval augmented generation this is going to be a huge module I hope you guys are pumped for it let's go ahead and dive into it now all right guys welcome to module number four where we're going to start learning about retrieval augmented Generation all also known as rag so in this quick overview section what I want to do is I want to talk about what is rag why do we need it and then I want to do a high Lev overview of like just running through a simple example just so everything makes sense whenever we start to dive into these code examples that I've set up over here for you guys okay so let's just go ahead and just talk about what is rag at a super high level and kind of why do we need it well these large language models that we have set up like chat gbt Gemini and llama 3 all of these models have a con straint on how much knowledge they already have and that can be a problem whenever we want to start answering questions or whenever we have questions about additional things such as like hey what's happening today in the news well these llms have a cut off date of you know a few months or even a year ago so it has no idea what's happening right now also when it comes to maybe just like inside of your company you have some specialized documents for y's processes or you have some other information about a product You're Building well the LMS obviously don't know anything about it so it's up to us to use rag to feed in additional new information to these lolms so under the hood all we're trying to do is just give these lolms additional information so they can answer our question that's all that's going on at a high level so as you can see we can feed in things like PDFs so whenever you hear people talking to PDFs or chatting with them that's exactly what's happening they're using rag so we can feed in websites we can feed in source code and video transcripts and the list goes on and on but okay that's enough at a high level so what I want to quickly do next is let's dive over to a big example that I set up for you guys where we're going to walk through exactly how rag works at a super high level so when we hop over to the code and we go through all these different examples you'll have a high level understanding of like oh that's why we're doing what we're doing so let's go ahead and dive into that high level overview right now all right guys so welcome to this quick overview of how rag works now I've put together this flowchart for you guys so that we can understand two critical components of working with Rag and I'm going to walk through both of them at a high level and kind of go super quick because we're going to go through this a bunch more times as we actually dive into the code but the main thing I want us to take away from this demo is for you understand the Core highle Concepts such as terms like vector store embeddings llms chunks tokens we're going to learn we're going to just quickly say all these words and it'll mean a lot more when we dive into the code and that's where we're going to be covering in part one and then part two of this quick demo I want to walk through like great well once we have actually saved all of the information from our PDF over to this special database called a vector store well how can we actually start asking questions and pulling out information so that we can get a AI generated response that's informed meaning if we're you know chatting with a document about how to like cook a specific food well we want to pull out the specific instructions for that food along with our question to generate an AI response so that's what we're going to be talking about at a high level and we're going to go pip part and this will hopefully all make sense and I do think one of the core parts to help this make sense of like why we're doing what we're doing is to actually start at the vector store and work our way back up so you understand why we're doing it because and this will make more sense so hang on for two minutes and it'll make all sense okay so at the end of the day everything that we're trying to do comes to this part right here it's the bridge and connection between our database which stores all the information about our Tech Source plus this Retriever and this retriever is where we're going to like hey man please give me all the information about you know let's just say we're working with Harry Potter and we ask like hey which Professor also is a werewolf well what we want to do in this example is we want to be able to look up things such as like professor and werewolf how well if we were manually doing this what we would do just like command F in a PDF and just search for those words a thousand times but there's going to be a ton of entries and what we're trying to do is really find a werewolf and a professor that's the information we're looking for okay so what we're trying to do and this is a keyword here we're trying to look for similarity inside of the original teex source that we're looking for that's all we're trying to do we want to look for similar pieces of information inside this original PDF that talk about professors and werewolves okay so that's all we're trying to do here now well how does this actually come into play when it comes to rag well what's going to happen under the hood is this PDF of Harry Potter is going to be broken up into a thousand different chunks because you can see this PDF is has about 10 million tokens and that's way too big for us to answer any questions or like analyze what's going on because chat gbt has a window of about 8,000 tokens and 10 million is obviously way too big to pass into it so what we need to do because we're just trying to pull out the similar pieces of information and pass it over to jbt so it can generate an AI response about it so what we need to do is we need to split this up into a bunch of smaller chunks that are about a th000 each what's great about this is because like I said chbt can take in 8,000 prompts 8,000 tokens so if we pass in one chunk up to three or four chunks there's still plenty of room for us to also pass in a question about those chunks okay hang on we're getting there all right well each one of these chunks is just plain text so you can see like chunk one is just like you know Harry you're a wizard and you know and basically how this is working under the hood is we're just starting at the beginning of the book taking out a thousand words putting it a chunk putting it getting the next few thousand words putting in another chunk well the problem is we said our original goal is we went to look up similar phrases well how the heck does AI compare and search for similar phrases well this is where the term embedding comes into play an embedding is nothing more than the numerical representation of text so that was a mouthful what does that actually mean well if we were to like in this super simple example if we were to embed the word dog cat in house you can see that a dog has this embedding a cat has this embedding and a house has this embedding and you'll notice they're nothing more than just a list of numbers but they actually under the hood have some meaning and relationship to to one another so for example a dog and a cat are super similar the only thing that's different are these last two numbers but even then they're not that different cuz they got four legs they're furry they live in a house but a house on the other hand it's got a roof it's got walls brick they're completely different subjects so if we were to ever like search about dogs or animals with four legs well these two things would come together these are super similar so we would get responses about dogs and cats so with the point I'm just trying to get across is embeddings allow us to easily in search for similar items and the way we're able to do this cuz like machines love numbers and numbers are easy to compare and see how different and similar things are okay so what we're going to do is we're going to convert these chunks of text over to embeddings so that we can easily compare them and contrast them and once we have all these different chunks of text embedded what we're going to do is start saving the embedding plus the original text to a vector store and the reason why this is important is because going back to our original problem what we want to do is we want to be able to ask questions and retrieve related documents from this Vector store all right so now let's walk through this flow down here now that we're in part two and you'll see exactly why everything that we just did above is super important so going back to us with our Harry Potter fans if we ask a question which Professor is also a werewolf well that question will be embedded itself because what we're trying to do is see we're trying to look up similar documents to our question and the way we're able to do that is because our embedding we now have a numerical representation of Professor and werewolf and and then eventually cuz now it's embedded now whenever we go to our use our it's going to be called a retriever whenever we use our retriever to look up similar embeddings in the vector store it'll go like oh well chapter 4 paragraph 1 2 and 3 all talk about this professor that's a werewolf let me give you back those chunks of data or those Blobs of text so that you can then ask questions about them so that's all that's happening under the hood we go step one here's my question here's my embedding that has my question great let's return this chunk and this chunk because those were the most similar and once we have those chunks returned what we can do is pass them over to chat gbt and what's going to happen under the hood that you'll see is all that's doing is is just adding those pieces of text at the very beginning of our prompt and then at the very bottom we'll have our question and then we can now ask questions about those pieces of information so what it would really be is like which Professor is a werewolf and then these three chapters or these three PA paragraphs will have all the information we need to generate an AI informed response now that was a ton of information don't worry we're going to go part by part when we look at the code it's just at a high level the main thing I want you to understand is we have huge Tech sources that have way too much information for any AI to consume we need to break it up into smaller chunks those chunks need to be converted over to eddings the reason we need to do that is because we need to see how similar each different chunk is to one another so that later whenever we go to ask questions about those different pieces of text and embeddings we can go oh yep these two are super similar here's the information you requested back so that you can ask a question so that was a mouthful let's actually go ahead and start diving over to the code now so we can see all of this in action and I promise you after you see this a few times it'll all make sense and you'll be able to start building your own rag use cases so let's go ahead and hop back over to the code all right guys so welcome to the first code example inside of the rag module and I'm super excited you guys to see how everything ties together that we just walked through in the highle drawing so this is exactly where you're going to connect the dots you're just to paint a road map of what we're about to do is I have broken up the first code example into two parts as you can see there's a 1 a and a 1B 1 a directly ties to the initial breakdown of what we were setting up top in our initial drawing drawing where we were first converting some Tech Source over to our Vector store so that's going to be in 1 a and then 1B is going to be all about actually asking questions and retrieving documents from that Vector store so everything we talked about when it come to like embedding chunking saving stuff through the vector store that's all going to happen in 1 a and then building our retrievers once again embedding you're going to see that all in 1 B okay so we're going to go ahead now and start walking through this code part by part and some of this code is a little bit more advanced just because there's a lot more moving Parts but don't worry I'm going to cover everything and once again if you have questions you can always head over to the fre School Community I created for you guys just take a screenshot or a Tim stamp of the video and say Here's Where I'm stuck I don't understand this and myself or someone else in the community will be sure to help get you unstuck so you can keep going and building out your awesome projects all right so let's go through this part by part and also walk through some of the folder structure just so it all makes sense okay so the first thing that we're going to be doing is inside of 1A is we need to set up some file paths so that we can connect to different parts of our project so the main things that we need to connect to is our initial text source so this is the document we're going to be asking questions about in this case we're going to be asking questions about the Odyssey and you can see how we access that book is by looking inside of our current directory go to the books folder and then look for the Odyssey text so if right now U my current directory is inside of the rag folder if I open up books you can see that I actually have the Odyssey text file right in here so that's how we're going to access that and then next thing is you can see I have this what I'm calling a persistent directory so that's actually just where I'm going to be storing our chroma database and same thing this one we just look at the current database open up the DB folder whenever you start to save files this will actually Auto get created so you might not see DB out the gate and then next we're going to save everything to the chroma DB folder so that's what you can see now this is since I've already ran this code before I already have this but I'm going to delete it so I'm on the same page as you guys Okay cool so let's keep chugg along in our code and so you can understand what's going on so if you remember the first part of what we're trying to do in this highle code is go from a Tech Source over to our Vector storm so if we've already went ahead and chunked our document converted everything to embeddings and saved it to our Vector store there's no reason to rerun 1A so this is why I have this code right here it's just going to say hey does a persistent directory already exist in this case the chroma DB already exists if it does just completely skip all of this because there's no reason for us to go off and you know there's no reason for us to go through and pay because embeddings do cost money to convert from text to embeddings so we're just going to completely skip it but if we do not have that persistent directory what we're going to do is go off and actually set everything up so the first thing that we're going to do is we're going to start at the top and actually load in the file path and what I'm going to do to help this make sense is we're just going to quickly hop back and forth from part to part so it all makes sense so first thing we are going to load that file path which is connected to our Odus text and we're going to use a text loader a text loader is just a great way to actually like Point like yep here's the file path to my document that I want to load later on we'll talk about things like web loaders to where you can actually pull information from the websites but just I'm just want to like expose you to the realm of the possible but right now we're just going to load a text document once we have that file loaded what we're going to do is we want to actually start splitting up this document into small chunks exactly like we talked about here so so far we've loaded it and now what we're going to do is start chunking it and there's a bunch of different chunking strategies that we will talk about later on in the text splitting Deep dive but for right now just know we're going to try and chunk our basically each section of the book every 1,000 characters and just to go like a little you know help explain a little bit more just so we're on the same page you can also set this thing called chunk overlap and all that does is let's just say this is a chunk of text and let's just say in the middle of a paragraph Was A characters what it'll do is it'll cut off so you kind of get cut off in the middle of a sentence and then when you load the next chunk it's kind of like well I have a query about the end of the first chunk but it's about the second chunk too so it just I don't know it's it's just difficult for us to understand semantically what's happening in a chunk so what you'll notice a lot of times people do is they'll set some overlap so what that's what that'll mean is just like you'll always grab a little bit of the next section too that way there's there's just always overlap and a lot of times you'll get better performance results so a lot of times just like give you numbers a lot of people will do things such as like 200 or 400 or common values so yeah but right now for example we're just going to keep everything lean and mean and set the chunk size to 1,000 tokens fantastic so once we have set up our text splitter what we're going to do is actually split up our original documents into a ton of those chunks that you see right here each one's going to be a th000 tokens now once we have all of our chunks also docs whatever you want to call them what we can do next is we need to start moving over to in embedding them now in this casee we're just going to use the open Ai embeddings and we'll actually go through later on in an embedding Deep dive to show you other options that you have but for right now just know that we're going to use open AI to convert our text chunks over to embeddings and we're going to be using the text embedding three small model and there's actually a few different models that you can use there's one that's three the three small which is the cheapest one and I that's one I primarily use and there's also a three large just just know as we talked about earlier there's this things called numerical representations where just which were just long arrays of like a dog is equal to like an array of like 1 two three well the large model just has a lot more values so we can get a lot more precise with our embeddings so just just know three small is probably completely fine for the projects that you're working on okay let's keep chugging along so once we have set up our embeddings what we're going to do is we're going to use our chroma Vector store to actually save all of our documents with our beddings and we're going to say you are going to save the results over here into this persistent directory so what I'm going to do is I'm going to run this just so you guys can see what it looks like under the hood so we're going to run python this is the fourth module and this is 1A and we're going to run R rag Basics I'm going to zoom out so we can actually see it so you can see we are creating our embeddings we're finished creating our embeddings and then now we're going to create our Vector store if you scroll up actually a little bit you can see we saved a little bit of our first chunk cuz in our code we said you you know how many chunks do we create in this case 826 where each chunk has a th000 tokens and you can see the first sample chunk and this first sample chunk is actually the very first part of the book so if you go open the book you can see at like line one this is the exact same so yeah we've actually just you know this is working hope you guys are hype to see it's all all coming together all right so let's go back down to the bottom so you can see our Vector stor is created and we can confirm that by going over to our database folder and checking for our chroma DB and you can see at the beginning DB chroma DB yep it made it and just to show you guys if I actually try running it again the way we've set up the code is it'll give us an alert saying Yep this Vector store is already created no need to redo it cool so now that we have that set up let's go ahead and move on to Part B where we can actually start asking questions and pulling information from the vector store so let's walk over here to 1B and start going through this once again part by part so per usual what we need to do is we need to have we need to point point to our Vector store so that we can actually start you know referencing it so in this case copying the same thing look inside our current directory then actually access the database folder and look for chrom ADB once we have that set up we need to specify which embedding we're going to be using and we're just it's important to use the same one just so that you know you wouldn't want to change languages when you're asking questions so like we just need to be very specific and use the same thing consistent or else you're just going to get some weird results fantastic next what we're going to do is we're going to use chroma DB once again we're just going to spin it up saying yep here is the persistent directory where you've already saved all of your edings in those text chunks and here's the embedding function so that whenever you get asked queries you know how to go off and do a similarity check and see which relevant documents are the most similar all right so in this case all we're going to do is for this question we're just going to ask the Odyssey so the main character is Odus we just want to know who is his wife so this is the query that we're going to be asking to our Vector store and I do think it is important for you guys if you haven't seen what Vector stores look like I actually think they did a great job this is the chroma DB website and I think they did a great job of helping you guys visualize what's going on so under the hood you can see we're going to ask a query so who's ODS is's wife we're going to convert that query over to an embedding once we have that embedding what we're going to do is access chroma DB and it will pull out the documents and they're connected embeddings cuz like that's how we can do the similarity score door and we can see like oh this one's the most similar and here's the related document let me pass that back and once you get passed back you know it eventually gets passed back to your whatever llm you're working with and generate that AI response so I just thought this was a neat little graphic I wanted to show you guys let's go back to ours though so we can keep cranking this out so what we need to do next is work on that Retriever and the retriever is what's going to take in our query and eventually return back those related documents but when we're setting up our retriever we have a few different different options for what we can do and per usual what we're going to do is I have a deep dive later on so you can see all the possibilities when it comes to working with Achievers but for right now just know we have a few different search types that give us different results and for this example we're going to be doing a similarity score threshold all that does is pretty much exactly what it says it's going to do a similarity check to find the most related documents and it's only going to return documents that you know up to us how similar so this number you can see we have something called a score threshold well the higher this number is the higher the text document has to be to our query and we'll play around with this just so you can see it in action and the other argument that you'll see is this random letter K with a number so what the heck is that well what it's going to do is it's going to return the K closest documents so if there was 100 documents that were you know that were Above This threshold what this will do is it will return the top three closest results so that's how you have to kind of set up your retriever if you want to uh to do this and feel free to bump this number up or down just remember depending on which llm you're working with you're kind of capped at you know right around usually 8,000 tokens so in this example we're going to be pulling out 3,000 tokens whenever we're all said and done and passing it to our llm okay so now that we have set up our retriever set up the parameters what we can do is we're going to call that invoke function remember we talked about that a lot in the chat model section invoke is the magic word inside of link chain for actually taking action on the models that you set up so in this case on our we're going to pass in the query invoke it and it's going to give us back the relevant documents so I'm going to go ahead and run this and then we're going to play around with some of these parameters just so you can see what's happening under the hood and I do want to point out all we're doing in this example is just showing the relevant documents later on we'll actually pass these documents over to a chat model so we can start interacting with them but for right now I just want to show you guys that yes our Vector store is returning related documents and we'll just look through them okay so let's come down here clear this up we're going to run inside of our fourth module we're going to run 1B to actually start grabbing those documents and let's run it okay so what I would expect is to eventually get back three different documents that relate to OD deus's wife so you can see we have document one document two document three that's cool it also includes a source we'll talk more about that later but the main thing right now that you can see is his wife is Penelope so you can actually like kind of see like we're talking about in this document M we'll actually just do a quick search so you can look up like the term wife it gets mentioned in a few of these documents so yeah you are indeed blessed in the possession of a wife endowed with such rare excellent of understanding and so faithful as Penelope so that's like you can see this document perfectly describes you know like this is his wife so in the other documents too kind of talk about you know some of the other they they refer to wife so they're not as similar but you can see this was the closest one that's why it's document number one all right now that you've seen that work what I want to do is show you how we can play around with some of these parameters to get different results so I can actually bump this up to k equal 10 and I'll bump this down so we basically we're we're lowering the threshold and saying we want more results so what we're going to do is I would expect to get back a bunch more documents this time that are related to a wife so you can see yeah we got back 10 more documents this time let's see how many times his wife's mentioned penelopy yeah so these These are getting less relevant seven out of the 10 documents referred to her okay so what I want to do next is I want to show you guys what happens if you get a little too stringent so let's just say we only want to have documents that are like super super close to our initial question so if we were to run this updated code where we've updated the threshold to 0.09 meaning like very very similar what we'll do is we'll probably run into the problem of like hey you were too strict with your search results I couldn't find anything so we're going to give it a second and whenever it gets back to us it'll probably tell us hey man cannot find that oops it looks like there's a quick bug let me just close this out clear it out let me try this one more time and now it should hopefully give us back an answer yeah so you can see this time for whatever reason it just hit a bug yeah there are no relevant documents that retrieve using the relevant score 09 so we know we got too strict so that's uh just you know as you're building your own rag applications if you're not getting back results you might just be a little too strict with your similarity score okay cool well that's it for module number one now what we're going to do from here is just to paint a road map for you guys we're going to head into part two where we're going to start adding metadata to our document so we can actually kind of see like oh this is where this Source came from so we're going to go ahead and learn how to add metadata and view it in our request let's go ahead and start working on that now hey guys so welcome to the second example inside of the rag tutorial and what we're going to work on in this one is start setting up metadata now why is metadata important in context of rag well it all has to come back to the fact that lolms hallucinate and what I mean by that is Hallucination is a really nice way of saying they just get stuff wrong but what's cool is whenever we start adding in metadata to our rag queries what we're basically doing is allowing our llms to respond with like here is the source of information for where I'm generating this information I'm passing back to you so if we were asking a question about a meeting that happened in the past at our company it would tell us like oh John said this and Bob responded with this and it would say in here's the source where I got this information from so you could always just click the source go check it out on your own and be like oh yeah that is exactly what happened and dive into more of the details that went on in that meeting so that's metadata at a high level now let's actually dive into the code example so you can actually see how we set this up in practice and you're going to notice this is super similar to the rag Basics tutorial we're just adding in a little bit more complexity so you can understand all the capabilities of working with rag okay so per usual what we're going to do is set up our current directories but this time what you're going to notice is instead of loading a specific book we're loading a bunch of books and that's because what we're trying to do in the end of this tutorial is ask about a certain character and a certain book and we would expect the documents to we would expect our retriever eventually to only respond with documents related to that character so you'll see exactly what I'm talking about we're going to ask about and Romeo and Juliet so we would expect to only get back information about Romeo and Juliet and and the metadata related to it but you'll see that set up in just a second okay so what we're going to do this time is we're going to start using a different database so this time we're going to be using chroma DB with metadata I've already set mine up and you'll set Yours up in just a second but the main thing this code is identical to the other one we're just going to check to see hey does this persistent directory not exist if not let's just go through that main process we talked about last time which is going to be you know setting up our Vector store if we already have the database completely skip it so let's walk through what's happening under the hood when we are setting up this Vector store because there are a few differences in this one the main one is to start off is we are going going and searching through each one of the files in our books directory and we're going to grab all the files that end in a.txt so we're going to be grabbing all of these different books right here and what we're going to do with these book files is we're going to iterate through each of them and start copying the same process we did last time except for one tweak where we're going to add metadata here's what I mean first we're going to actually set up a new file path by joining in you know the name of the book file with our local books directory then we're going to load that book just like we did in the last example but what we're going to do now is once we have that document loaded we're going to add some metadata to it in this case we're going to set up this source for this document so whenever we're loading for example the Frankenstein book we're going to say the source of this book is Frankenstein or whenever we're looking at the ilad what we're going to do is we and you know retrieve a document it's going to say the source of the retrieved information comes from the ilad and you could definitely get a lot fancier with this you could break up your documents and set it up to be per chapter or per you know if you had a long meeting you could set it up to intro you know speaker one speaker two you could do it however you wanted to just so whenever you're setting up your metadata you could have like chapter and so forth and so forth but in this example we're just going to stick to a book Source cool once we have set up our metadata we're just going to add it to our documents array or list and then from there we're going to copy the same process first we're going to iterate through each one of those documents that we have and we're going to use our character splitter to chunk everything up into 1,000 tokens once we have our Docs we're going to do the exact same thing where we're going to pass in our docs plus our embeddings over to our Vector store down here so that we can go ahead and save everything okay so I hope this is making sense because now we're going to hop to 2B so we can actually start asking questions to our Vector store and pull out documents so what we're going to do in this example is once again set up our file directories and make sure we point to that new Vector store that we just set up the one that's going to be having metadata so this one right here and what we're going to do is we're going to use our our new embeddings plus our Vector store so that we can instantiate our new chroma instance so we can start passing questions to it now this Vector store retriever is the exact same as last time all we're going to do is just use similarity score I want the top three result and here's my threshold I set it super low for this one just cuz for whatever reason it was being a little weird however let's go ahead and run this code so you can see what it's doing under the hood so we will do python we are in the rag module this is the second exle to be so we're going to go ahead and run it and what I would expect to get back is information on how did Juliet die plus the metadata okay so you can actually kind of see it right here like in document number two Juliet's talking she obviously thinks Romeo killed himself and out of true love down here she stabs herself so like you can like it actually went ahead and just gave us the exact piece of information we were looking for which is crazy that it did that so efficiently and the part that's EXT cool is you can see this is the source where this information came from so you can go back and double check the AI to make sure it didn't just come up and hallucinate with some some weird facts yeah that's how adding metadata to your rag queries works at a basic level I hope you guys appreciated that and what we're going to do next is actually start doing some deep dives into each of the elements that we have been using to basically do our rag queries so we're going to head over next and do a deep dive into text splitting then we'll you know keep going down the chain from there so you can see all As specs and how we can add in some variety to our rag queries so let's go ahead and move over to part number three so welcome to example number three inside the rag module this example is all about going deep into different options when it comes to using the text splitter so what I what I mean by that is there are a bunch of different ways you can actually go about splitting up your large documents and you're going to in this example explore all of them so how to split it up based on characters sentences you know paragraphs and more we're going to be doing all that in this example and we're actually going to be spinning up a bunch of different Vector stores so that you can see how all of the different text splitting methods compare contrast when we actually make a query so you'll see exactly what I'm talking about here in just a second and per usual we're just going to start at the top of the code work our way down so that you understand everything that's going on all right so let's go ahead and dive into the code so the first thing that we're going to be doing is setting up our basically our normal file directories so we're going to just say like Yep this is the book we want to analyze and here is the path to our databases and you'll notice that we don't have a specific database called out yet and that's because we're going to be dynamically spinning up about four or five Vector stores down below okay so what we're going to do just make sure everything exists and we're going to do the normal you know kind of set up our normal loaders this time we're just going to load our book Romeo and Juliet grab the document and stand up and specify our Vector store or sorry our embeddings now here's where things get interesting what we're going to do as you can see I have I think five different examples to show you guys and each one of these examples kind of specifies which text splitter we're going to be doing and when it's useful to use this text splitter just so you guys always have a reference to come back to of like oh yeah I think it was text splitter number three that was good for this scenario and you can always just come back and actually explore but here's what's happening at a high level and then we'll dive into this Vector store function that's a little bit kind of it's it's different so what you'll notice is we're going to specify a specific type of text splitter along with the parameters we want to use and after that we're then going to actually go ahead and split up the document and once we have all those split up chunks what we're going to do is then call this create Vector store with all of our chunks and then we're going to give this database a name and once we do that and pass over that information we're going to call this create Vector store and what you can see in here is we're going to finally specify our persistent directory here and then actually go ahead and Save save everything to our new chroma database so that's exactly what's happening under the hood okay so let's walk through each one of these and I'll tell you when you should use each method and then at the very end we're actually going to go off and query the vector store okay so to start off the first type of splitting we're going to do is just the normal character-based splitting in the past what we've been doing I'm just going to show you what we've been doing for 2A in the past so you can see what we've nor been doing is character based splitting so this is nothing new this time we're just adding some overlap and you can see this is a great method to use when the type of your content doesn't really like there's no syntactical kind of meaning for example like if you're reading a book we talked about maybe keeping paragraphs together because we kind of want to like keep chunks of information together so this is just great when we just need to Chunk Up and split a bunch of random information the next example I want to show you guys is sentence-based text splitting so this one is when we actually want to split Things based on you know a sentence so this way you know maybe pair graphs are too long so we're just going to split everything based up on sentences so we're going to look for you know periods explanation marks question marks so and that's how we're going to split things up and once again we're going to be splitting things into chunk sizes of a thousand we're going to call this our chroma sentence then keep chugging along the next one is going to be our token text splitter and so this actually splits based on a token so in this one what's going to happen is we'll actually maybe split in the middle of a word so if let's say a word word was super long and you know maybe the first part of that sentence was right over the the chunk limit well half of the words going to get cut out so I would not recommend this for a lot of you know a lot of like documents based but I just wanted to show you guys that this does exist all right the next one that I just want to show you guys is going to be the recursive character splitter this is the one that I would actually most people use I've seen people use this the most and I would definitely recommend using number four the most cuz like it tries to naturally split around sentences and paragraphs within the character limit so it does a really good job of like making sure the information that gets pulled out just kind of it makes sense it would make sense for this cluster of information to be stored together okay cool and the final one I just want to show you guys is going to be custom teex splitting and all we're doing with just to show you guys we can make our own Splitters and these Splitters you can specify like oh I want to split chunks based on at the end of a paragraph so this is what this you know double backspace it's just a it's a double Escape or two new lines so in our case we're assuming that's a new paragraph okay cool and we're going to save that custom Tech splitter to our chroma DB custom fantastic so what we're going to do next I'm just going to show you is for each one of our databases that we just sped up Vector stores we're going to go off and query those Vector stores with this question how did Juliet die and the way we're going to do that is we're going to pass in the name of the vector store along with our query to this function right here and all it's going to do is look up our persistent directory that's going to be our Vector store and we're just going to do the normal thing that we've done so far to where we have have our Vector store we set up our retriever set up you know our search parameters for similarity score and then we're just going to grab the relevant documents and spit them out so that's exactly what we're going to do so let's go ahead and start running this query to embed everything first off using the different text spits and start asking questions so let's go ahead and run this and this is our third example so let's go ahead and do this is in the rag module and this is example number three so let's go ahead and run this super fast and this one will take longer because we're doing five six different types of settings but you can see that it's working we're creating everything so far we're based doing it for characters next we're going to do it based on sentences tokens and then from there our recursive and then finally we're going to do our custom text splitter and once this is all done we're going to then finally ask you know hey so how did how did she die and you can see let's just go result by result real fast just so you can kind of compare each one so the first one for character this is what we've been using so far and this does look super similar to what we've been doing it's just a lot of text from there what you can see when it comes over to the sentence one this one actually looks a lot more structured and then finally let's just keep going along when it comes to our token what I would expect to see at the very end of this one is like it get cut off at a random word so in this case it got cut off right at my but if this had been a longer word it would have got cut off and we wouldn't have been able to like you know we could have potentially lost some information when it comes to our recursive text butter you can see that this has done a really good job you know cutting at the very end of a of a sentence so that did a really good job or verse I can't remember what happens inside of a how Shakespeare wrote and then finally when it comes to doing our custom DB it didn't it you know it kind of just the way it chunked it it just didn't do a good job and that's because the way we sped up to split based on two new returns it just didn't do a good job of grabbing information but the main thing I just want you to learn is there's a ton of different ways that you can actually go about using different text Splitters to grab information my recommendation for you is to always use the recursive text splitter whenever for you're starting out and then you can get a little bit fancy using the token and text splitter and some of the sentence ones but just main thing always use the recursive but enough of that let's go ahead and dive into the next module where we're going to start talking about the different types of embeddings that you guys can use inside of your your rag setup so let's go ahead and dive into example number four right now so welcome to example number four inside the rag module and in this example we're going to do a deep dive into embedding just so you can see what's possible okay and just to give a little bit of background so far we have strictly used open AIS embeddings and in this example I'm going to show you how you can start to use custom embeddings why you'd want to do that and show you some other models inside of the open AI embeddings that you might want to use okay so let's quickly run through the code so you can see what's going on and then at the end we'll run it so you can actually compare and contrast two different results using two different embeddings so you can see which one works better and which one doesn't okay so what we're going to do is our per usual we're going to load in a book that we want to ask questions about and what we're going to do in this one uh per usual you'll see we have a database directory because we're going to end up creating two different Vector stores in this example and after that what we're going to do is per usual go ahead and load our document and we're going to split it up in this case we're just going to use the character splitter and once we have that set up what we're going to do is we're going to end up using this function called create Vector store more than that in a second the important part is I have two different embeddings down here so let's walk through each one super fast so the first one is once again like I said we're just going to be using the open AI embedding and so far we've been using the let me go ahead and just show you the exact one we've been using we've been using it's called text let's see text embedding three small this is the embedding that we've been using the entire tutorial and now we're branching out and we're going to be using the Ada embedding okay so let's actually go ahead and look how these compare price wise and actually look at what the different options you have so over here on the open AI website you can actually look up embedding and you can see there's a few different examples so this one is going to be the Ada example version two this one is one of the more pricey ones and you can actually go under the hood and and look at the different options they have so Ada so you can see if you scroll deeper down they have different qualities so the adaa example has it performs a little it it doesn't perform as well as some of the other options but you're able to add more data compared to the large model so it's all a procon but personally I just go with a small model for most of the stuff I work on just because it's the cheapest and you get really good results but the are other options and I def want you to be aware of that okay all right let's hop back to it so what we're going to do in this case is we're going to create a new open AI embedding using this new model and that's option one and like I said these open a Bings they're best just for general purpose with really good accuracy and then but remember you have to pay because this is all happening on open AI servers now option two what this embedding is going to be is we're actually going to download an embedding model from hugging face hugging face is just a like I'll just go ahead and show you guys what it is so you can see it in action so let me pull up these models for yall real fast so as you can see whenever we head over to hugging face which is just a great place to go ahead and download models that other people have created ated locally on your machine so you can run them completely for free so you can see there's a bunch of different models here and we can actually search for embeddings we actually already searching for beddings and you can see there's just a ton of them yeah dozens but in our example what we're going to do is use one of the more common ones which is just going to be a sentence Transformer and all it's going to do is its main thing is it's going to like I said it's basically just going to run locally and perform in beddings personally I don't really use these that much I just want to show you what's possible the main Pro and the reason why you would want to use one of these models from hugging face is because you can run it locally for free which is one of the biggest benefits it's usually not as performative so you're kind of trading performance for cost so it really just depends where you fall on that Spectrum okay so what we're going to do next is now that we have gone off and specify the two different embedding models that we want to use and the different names we want to call these different models for our Vector stores we're going to go ahead and create those databases now you've seen this before what we're going to do just pass in the the embedding and this is going to just passing right here so we're going to set up the vector store name and then we're going to say which embedding to use and that's how we're going to go off and create our two Vector stores one for open Ai and one for hugging face now it is important to mention whenever you do use this embedding because it is running locally on your computer you're going to download a pretty big file I think it's half a gigabyte but that's how big the file is to perform your embeddings locally so it just beware if you're going to download this code and run it it does uh take up a good bit of space and might be even more okay so what we're going to do next is we're going to do our normal comparison where we're just going to ask a question to our Vector stores and we're just going to compare the results of open AI to our hugging face example so let's go ahead and go ahead and open this up and we're going to run our fourth example so four because we're in the rag module fourth example going to go off and run it now what you'll notice is I've already gone ahead and actually created these models in the past so it's not going to generate a new hugging face Transformer cuz I've already done it in the past but you will see that we are going to be able to query these documents so in our open AI example output let's see what words we get back so we didn't actually get a good example in either one of these so what we can do is update our Vector store and we can actually update our K to get back more results clear it run it again and this time we can actually hopefully search to see if we got back any information about OD deus's wife who in this case is penelopy and it's so funny because sometimes you'll get back an example that does include the right information so you can see now it just changes per run so you can see now in our hugging face example we got some information about Penelope we got one of the documents contained information about her and then if we go back up you can see that our open AI example came back with a few more examples talking about Penelope so overall they both got towards the right answer it just open a returned back a lot more relevant information so kind of what we expected it's more performative at the cost of spinning a little bit more M on it okay cool enough with doing our embedding Deep dive what we're going to do next is we're going to move over to working with retrievers and learning about different search types and different arguments we can pass in to our retrievers and this is really going to help up our game when we're working with different rag applications all right let's go ahead and head over to example number five so welcome to this fifth example in the rag module in this example we're going to be doing a deep dive into retrievers and understanding all the different ways we can actually update how we search for different documents inside of our Vector stores so that's the main goal of this quick Deep dive okay so what we're going to do as a high level just to also understand we're going to by the end of this example showcase how by fine-tuning different search parameters and our retrievers how we're going to get different results so you're going to learn more about different types of search queries and different ways to basically you know pass in custom parameters for those different types of searches and we're going to be able to at the end of this compare and contrast the different results okay cool so let's quickly run through this one so the main thing we're going to do our normal part of setting up a accessing our Vector store in this case we're going to reuse our old Vector store which included all of our metadata so this is one that had all of our books with the different sources outside that we're going to use our usual embedding model we're going to spin up our chroma DB instance and then from here what we're going to do I'm going to close that out and we're going to come back to this query Vector store but what you can see is we're trying out three or four different examples of searching inside of our Vector store so what you'll notice is let me just show you like a a compare and contrast so the first thing is we pass in the name of the vector store that we want to search the query so this is like hey what question do you have what type of embeddings are we going to use and then here comes the important part we're going to pass in what type of search basically what type of search model we want to use and then any parameters so let's actually hop into this query Vector stor you can see all this in action under the hood so like I said you can see the search type and the search type parameters right here so we're dynamically spinning up and creating our retriever because that's the main area that we're focusing on in this tutorial we want to compare and contrast all the different options and not only do we want to like access these retrievers we want to go off eventually and fetch information with these different types of retrievers so that we can compare and contrast the relevant documents just so we can see like oh yeah this search type performs better than this search type okay so let's hop back down to our three examples below so that you can actually see how they work so so far what we've been using is and the rest of our code has been let's scroll down so I can show you we've been using similarity score with threshold basically so this is how we say yep I want to get the top three results and I only want to get back information that's over this score threshold that way we only get back relevant data however sometimes you don't want to actually do that threshold scoring if you know for a fact like yes every question I'm going to be asking is relevant to that database you really don't need the threshold so this is a very quick way to say yep here is my data store I want to just grab all the similar results don't care how relevant they are I but I do want to grab the top three results that's exactly what's going to happen with this similarity score and there's no way of really filtering out the like oh yeah this one's not that relevant okay the next one that we want to do is working with the max marginal relev an search query so what does this one do why is it important well what it does is it tries to not only get the most relevant information but it tries to kind of spread out meaning if for example how we're going to ask about questions about Juliet's death well what this type of search score would do instead of sorry I'm going compare and contrast with this similarity score let's just say all the top three documents about her death were all right next to each other so it's just going to grab all of that information and maybe leave out some additional context and what's cool about this Max margin result is not only is it looking for super relevant information but it's kind of also looking for adjacent information around her death so it's not just going to be like yeah she died because of blank it's going to maybe skip around to like a few paragraphs later that's also talking about her death but it might not be the most relevant information to help generate a more well-rounded response so very cool search method and you can actually see Let's uh scroll down here so you can kind of see so yeah so K is how many different responses we want to get fetch K specify the number of documents to initially fetch so this is you know how we can actually kind of specify like we're going to grab a ton of documents and then inside of that we're going to return the top three and we're going to like space out those results so you're going to get a well Diversified set of results so this is what you can see kind of right here so feel free to play with this Lambda multiplier like I said the main thing it does is control the diversity so if you want a ton of spread out information to get like as much wide range of context around the topic as possible you're going to want to bump that number to zero to get the maximum diversity and if you want super similar information keep it to one okay cool so enough of that I'm excited to show you guys this one actually running so you can see how it performs and the final one this is the one that we've been using the entire time which is just our similarity score with a threshold okay so let's go ahead and actually run this so you can see how it performs and we're going to actually this time because there's going to be so much information um over here in my terminal and we'll look at the results over here so what we're going to do is run python this is in the rag section and we are on the fifth example so we're going to go ahead and run this code and it's going to go off and actually oh my bad I need to actually load in my environment variables I didn't do that real fast we'll just quickly fix that on the fly so we'll do load oops load. EnV and then once we have that we'll come over here and import it fantastic that was my bad save it now when we run it again it'll work and it'll actually go ahead and show all the different results for the different Vector stores okay so let's run through this part by part just so you can kind of see how it works so the first example that we're going to look at we have to come all the way up just because there are a ton of different examples so the first one is just the regular similarity score so you can see it is going to return three different documents that are the most similar to our initial quest which was how did Juliet die so we're going to get back a ton of information and then hopefully one of these will actually include the way that she died yeah so she stabs her health so yeah you can see document two include the exact pieces of information that we needed so the next one that we were wanting to do was the max marginal relevant score and this is the one that allows us to get not only the piece of information we want but some of more of the contextual information around her death so let's actually see if this result includes anything around her dagger so this one does talk about you know laying her dagger down and it also yeah this one didn't perform as well as the other one so this would be a good way for us to go off and actually potentially like oh maybe let's just get some less diverse information so we really hone in so like I said everything's a game and you have to optimize and tune those parameters to get the results that you're looking for and the third one which is our usual one which is hey let's go off and actually get everything that's within a similarity score this one is going to return per usual the one where she she snatches a dagger and stabs herself so like I said there's a few different ways you can work with these different retrieval messages retrieval methods to experiment with grabbing information from your vector store so I just want you guys to be aware of a few of the most common approaches but enough of that what we're going to do next is Hop on to the next example where we're actually going to not only be retrieving information now but we're going to actually ask a one-off question of like hey what happened and we're going to get an AI generated response let's go ahead and dive into this example next so welcome to example number six inside of the rag module I'm super excited for this example because you're finally going to learn how to tie all the information that we've been storing in our Vector store we're going to be grabbing that information and passing it over to an llm so we can actually finally generate an AI generated response so I'm pumped for you guys to see it so now that you know what we're going to be doing let's actually dive into the code so you can see how you can start chatting with your data okay so per usual what we're going to do is we are going to go off and grab our Vector store location per usual we're going to be chatting with our Vector store that has all the different options from all the different books what we're going to be doing is use our usual text embedding from there we're going to spin up an instant of our Vector store from there we're going to be passing in a new question and this one is just going to be hey how can I learn more about Lang chain and now that we have our query we're going to set up a new retriever in this one we're just going to use the similarity search method which is going to like I said just how we just learned about it's just going to grab the most relevant document and it's going to return only one result and from there what we're going to do is use the Retriever and go ahead and search our Vector store for that query and return relevant documents so it's important to realize that this is a list of documents now in our example we're actually going to print it so you can see the underlying document but here's where the magic happens what we're doing under the hood is we are generating a r query and we're not only going to just use our query we're going to pass in the content from our Vector store that we just pulled out combine them and we're going to use our chat models to generate a response so this is going to be awesome and let me just walk you through the prompt so you can understand what's happening at a high level so the first thing is we are creating our prompt and we're going to say you know here's some documents that might help you answer this question here's the question now here's the relevant documents we could have probably used a prompt template to do this and you'll see we're going to do some of that later on but we could have even done it up here and then what you're going to see is we're going to join basically we're just going to do some string manipulation here to where we're going to grab all the content from our relevant document and really just spit it out in a nice text format and if you remember each one of these documents because we set this up earlier when we were doing our embeddings each one of these is going to be a th tokens long so we're going to have plenty of space to pass in this information into our query because hey we're only getting one result so 1K tokens and we have up to eight so 8,000 tokens so what we're going to do is once we have this combined input we are going to spin up our new chat model and we're going to use the latest version of open AI so ct40 and we are going to go ahead and generate our messages and what what we're going to do is pass in our messages with our combined input containing our query and all the information from our Vector store into our model and we're going to invoke it and what this is going to do is generate a result for us which is going to contain the AI response and for this example let's just only generate the content only so you can just see the actual like response that it's going to say like well if you want to learn more about langing chain here is my recommendation so what we're going to do is go ahead and run this is module number four for rag this is example number six for a one-off question so let's go ahead and run it so what you can see is it'll hopefully spit back some relevant documents and then at the end it'll do the AI generated response with information from our documents so this is so cool so let me just show you the AI generated response first and we'll hop back up to the relevant doc so I was a little bit uh a little cheeky and what I did is I put in a document about myself inside of the book section and you can see I have something oh where did it go for you guys yeah Lang chain demo and what you can see in here is you know hey if you want to learn more about Lang chain you can go over here to the official documentation or if you want more in-depth tutorials and insights on Lang chain check out my YouTube channel and uh here's a link to it don't forget to like And subscribe especially if youve made it this far this video don't forget to uh to like And subscribe if you want to learn more about AI yeah as you can see it's generating an AI response that officially responds to our query in a conversational way and you can see this is the exact document text that we were able to like manipulate and turn and use for our AI response and if we actually look inside this text demo you can see I put a bunch of information and we got back the part in our response for further exploration yeah so in our the way just the way the chunking worked is we got this piece of text and yeah so I hope you guys think that is super cool for our oneoff example what we're going to do next is I'm going to show you how you can have a full-on conversation with your rag data so let's go off and start working on example number seven so welcome to example number seven inside the rag module this is definitely the most complicated example in this section however it is the most useful one and probably the example you'll use the most often when ever actually building out a rag solution inside of your applications for your users okay so what we're going to do in this one is we're going to quickly speed through all the parts that are similar and then we're going to focus on the parts of this code example that are different that allow us to actually have a conversation with our rag application so that we can you know ask a question follow up with it get additional information from our Vector store and just keep going so that's what we're striving to do here in this example so let's go ahead and dive in so in part one what we're doing is per usual we're just spinning up a Vector store that points to all the books we've defined what we're going to do is we're just going to use our usual retriever which is just going to be a similarity one to get the top results for this example we're just going to use CH gbt 40 as our llm okay so now let's dive into this part of the code that's all new so the main thing that we're trying to do here I think it's best if we actually start at the bottom to understand what's happening so what we're trying to do is we are trying to set up this retrieval chain all this is going to do is we want to be able to retrieve information from our Vector store we want to have awareness of all the conversations we've had up to this point and based on the information from our Vector store and our conversation we want to generate a result that is all we're trying to do and that's what's happening under the hood okay so how is this happening well there's a few things that need to happen part one is we need to be able to grab information from our Vector store well how are we going to do that well we're going to be using this library and function called create stuff documents chain what does that mean I know it's a weird term but basically what it's doing under the hood is it makes a chain for us that will take in a list of documents and pass it to a model so that's what it's doing under the hood okay so we have documents and we need to feed those over to an llm that's exactly what this Chain's going to do for us so cuz we have open Ai and now you'll be like okay well where do these documents you know where does this conversation and documents come from well let's keep working back up so next is to create this document chain we also need to provide some information about like what the heck's going on so that our llm is aware of what it needs to do well this is where our we are going to make a prompt for us we're just going to call this the QA prompt so you know question answering prompt and we're just going to say hey you're an assistant who does question answering use the following pieces of retrieve context to answer the question if you don't know the answer just say you don't know use three sentences maximum and keep the answer concise so we're really just going to say hey here's the Act exact piece of information you need to know from this rag query Okay cool so this prompt is then you know we're going to use our prompt templates back from module number two to pass in our basically just pass in our QA system prompt here to say this is your system context this is what you should be doing and then we're going to pass in our chat history our chat history will happen later on and that's as we chat with the our llm we're just going to slowly build out a list of messages and then finally we're just going to continually add in the human inputs every time the human has a question it's just going to get passed in as an input right here okay cool so now you understand how we have this question answering chain so this is going to kind of set up the whole part where we're like responding to questions now we need to have what we're going to do and call the history aware retriever so what is this well the history aware retriever this is where we're actually going to start passing in and working with our Vector store retriever remember retriever is how we interface and pull information from our Vector store and we're also you'll see here in just a second but we're going to do something very similar to where we're going to have our our AI our llm in this case who's going to be doing the thinking and generating some responses we're going to have a retriever which is pulling down the information from our Vector store and then we're going to have a prompt which is kind of sets the scene for what's going to happen next so let's go part by part so this all makes sense okay so for this history aware retriever we'll go start with a prompt so this prompt is saying like hey you're going to have some chat history and it's up to you to basically interpret what's being said and not answer the question but just kind of provide context for what's going on so this is all you're doing it's just you it's up to you to reformulate the questions so that we can properly search for information inside of the vector store so that's all we're doing you're going to get a question just rephrase it for the vector store so that we can retrieve the proper information so I hope that makes sense and then let's just go back and look at the other parts uh the retriever we've already set up we're just going to get the similarity score and we're just going to grab the top three result results and then when it comes to our llm we're just using chat GPT 40 okay so now that we have all of these different things set up we can actually go ahead now that we have our full retrieval chain that has two parts our history aware retriever which is pulling information from the vector store and we have our qu question answer chain which is actually like taking in user input and actually responding and generating answers to our users now that we have this entire retrieval chain set up we're going to call it our rag chain what we can do is start having a conversation with our llm and our Vector store so this is the exciting part so I hope you guys like it so what we're going to do is start asking uh we're going to go ahead and run the program so you can see it in action but I just want to show you at a quick level what's happening first we have a chat history and that chat history was important because we were using it up here inside of our contextualized prompt just so we can have a historical reference to what's being said okay and we're also using it in our question a prompt Okay so so that we're constantly adding messages to this so you can see here whenever we invoke our our rag chain we're passing in the users query and we're also passing in that chat history very similar to what we did when we were setting up our first conversations with our chat models in section one second what we're doing next is once we get the result what we're going to do is just print it out for the user to see and then we are going to append and update our chat history so that we have our initial query and we get back the result from the AI and we continually just add it in a pin it to chat history so that it's aware and we can have a full-on conversation all right enough talking let's go ahead and dive into the example so you can see that it's working so what I'm going to do is just go ahead and open up the terminal clear everything out and start our conversation so this is in module 4 and this is example number seven so what we can do is go ahead and run it and then you know it's going to start our chat conversation for us so we'll ask the same question we did last time how can I learn more about Lang chain what this is going to do is go go off and search through our Vector store and actually spit out a you know a response to us so yeah hey to learn more you're responding to us concisely like we asked using the information from the vector store it's basically consolidating to 3 CES as maximum answering the exact question that's awesome I also just finished Romeo and Juliet how did uh she die so let's just this is kind of going out out on a limb not sure if this one will work I just want to show you guys that we can actually have a conversation with it and we'll come back to my initial question just a second so that's awesome hope fingers crossed it'll come back and actually respond like yeah she kills herself with Romeo's dagger so the cool part is we have specified I just want to show you something we specified do not basically yeah if you don't know the answer just say you don't know and what's cool about this is the fact that it's not making up information it's pulling information strictly from our rag documents and going from there so we can try and ask something else so who is Brandon again and this is where we're actually going to start using some more of the conversational awareness because it's going to have to go Brandon oh yeah this is his YouTube channel so we would expect uh we would expect it to refer up to two messages ago yeah Brandon is the creator you can find his videos here so yeah so it's kind of doing the the full-on conversation part as well as the additional retrieval part where it's actually accessing our Vector store so I hope this makes sense to you guys this is like I said by far one of the most complicated examples in this whole module and really this whole course so if you have any questions please head over to school it's a preschool community and pop a question take a screenshot and say I'm stuck here don't understand it or I've been building this on my own and I keep getting stuck here please help and myself or one of the other developers in the community will try and help you get you unstuck but enough of this one let's go ahead and hop over to the last module we have which is all about web scraping and actually using information we get from the the web in our Vector stores so let's go ahead and dive over to example number eight right now hey guys so welcome to the final example in the rag module what we're going to be doing in this video is going over two methods for you to go off and scrape information from the web and add it to your vector store so that you can start asking questions and interacting with the data and what we're going to do is I'm going to show you a basic example first so you can see it's working and show you some of the cons and then we're going to go over to using a tool called fire crawl which is is awesome and want to show you how it's going to perform a lot better and provide much more better results really okay let's go ahead and dive in and go part byart so the main thing that we're going to see for the beginning is same thing per usual we're just going to set up our directories and set up our file paths and this one what we're going to do next is we need to start specifying a place where we want to start scraping the web in this case we're just going to go on apple.com and what we're going to do is instead of using the text loader like we've been using for everything else we're just going to use the web based loader which is going to go off and scrape the basically scrape a website for us so it's you know instead of looking through a book and loading it it's going to just go over to a website and load the information so that's what's happening under the hood and then everything else is going to be identical we're just going to split the text once we have split up the text into all the documents we're going to start passing over basically those split up chunks plus our embeddings over to a vector store that you can see right here so yeah we're just going to create a new Vector store from scratch and that way we can start accessing it once we have set up our Vector store what we can do is start asking questions to it and we're just going to use a similarity score and this one we're just going to grab the top three results and you know we're not going to chat with this data at all we're just in this example we're just going to get back results of like oh yeah these these documents have the relevant information okay so I'm going to run this one we're going to look through the results together and then we're going to hop over to fir crawl after we kind of go over the pros and cons so let's go ahead and clear this up and then we're running the you know we're in the module this is the eth example and this is the basic one so what we're going to do I'm going to zoom out so we can actually go through the results together so it's going to spit out a ton of information so this is just like the first one so you can see that it's going like okay well U we got five chunks from the Apple website here's the first one where you can kind of see like oh yeah we're talking about the Apple iPhone 15 Pro we're looking at you know just some of the main key phrases and we're adding all this information to our database so that's just an example one and then when it comes to actually asking questions to our Vector store we said what products are announced it's just spitting back this information so it's just like it's saying Apple intelligence it's saying iPhone 15 iPad Pro so it's it's really not like saying what's new just kind of spitting out what's on the website and uh yeah just going to keep doing that and just return a bunch of a bunch of information not super helpful so but it did work we can actually interact and it did a good job of web scraping so plus plus on both of those but the important part is I want to show you example number two which is using fir crawl just so you guys can see and compare and contrast the different results now fir crawl it is a free tool that you can use however they do have like you know they have some free usage for you however you do have like a paid version so let me just show you yeah so they do have like a free plan and a hobby plan but once you see how cool they are like like some of the results I think you like dang if you're doing a lot of web based scraping this is the tool for you make sure like super easy their key you know key slogan is like hey we turn websites into llm ready data so like you know here's a website that's gross oh we'll actually pull like a markdown version of this data for you so that it's easy to use and interact with inside of your llms so enough talking about let's actually go ahead and and use it and the one thing I do want to point out is once you've signed up a major free account you will have to copy and paste this API key over to your environment variables folder that we have or file that we've set up and you'll just go ahead and paste it in there so you'll just update the fir crawl and Pi just put your key in your you'll just put yours right here okay cool enough of that let's go ahead and actually start running this so you can see how this fire crawl example compares to the other one and the only thing that I'm going to just say different uh cuz some of this code is like well this is weird what's what's happening I will run through it real fast you know set up your create your new persistent Vector database for your vector store we're going to call this one fir crawl and this time because we can't just do web loader which goes off and does everything for us we actually have to uh be a little bit more specific using the fir craw loader tool so this is a package that you can install and if you actually go back to our py project. tommo you will see that we have where is it down here yeah you will see that we have a fir crawl package so this is how we're accessing this tool but hey we're going to use the fir craw loader here's our API key so you can validate that we are allowed to do this here's the website I want you to go scrape and they have a few different modes ones I think called crawl and one's called scrape crawl just go to a whole website and mode goes through like a single page so I would defin I'd use scrape to start off with CU you can easily blow all your tokens if you crawl so once you have scraped that website we're going to load all that information like we normally do and what we're going to do in this one is we're actually going to chunk through that document that we have pulled out and we're going to add a lot of metadata that you'll see later on so it's actually pretty cool this the setup they have and then what you're going to do next split everything up into different chunks pass over those chunks plus the embeddings over to to a new Vector store and once we have that Vector store set up we can start asking and making queries to it okay so enough of that let's go ahead and start you know let's go ahead and start testing it out so what we're going to do in this one we're going to do Python and the rag module this is the eighth example and this is fir crawl so we're going to go ahead and run it and it'll take a few seconds to go off and scrape the website beginning to crawl the website and I might need to update my question just because uh wwc 24 was a little bit ago and uh I'm sure a lot has happened since okay so the main thing is we grabbed 14 chunks of information compared to you know whenever we were running the other example we only grabbed you know three or five so we're grabbing a lot more information because the fir crawl does a much better job of actually you know pulling out information and it actually I don't know how it works under the hood but they do a much better job of like getting around like a lot of websites only load HTML whenever you try to use a tool like web loader they only give you h HML so you're missing out a lot of the JavaScript code that gets rendered so that's how we're grabbing so much more information when it comes to fir craw so under the hood you can see now whenever we ask you so you can see in a sample chunk that like hey we grabbed well for whatever reason it chunked it too much but you can see whenever we look at like relevant documents we can start to see some of the updated questions that are related now it didn't do a fantastic job but let's update it to talk about Apple intelligence tell yeah whenever I wrote this first query I made it for uh basically I did it back in the day whenever wwc 24 was about to happen so now we're going to do a second question and this time what it's going to do is provide information strictly about Apple intelligence so yeah document two all about Apple intelligence so like I said much cooler you can actually see a lot more of like the links now if you want to go off and actually like interact and actually pull this information and using a sales page isn't the best example using things like like Reddit or places like that where you want to actually like pull actually a lot of content from like a lot of users conversation that's a great place to try out fir crawl so but enough of that I hope you guys enjoyed seeing how you can actually start pulling information from the web you can go really deep into a rabbit hole when it comes to this but just for now when it comes to like scraping Basics this is plenty to get you guys started but yeah enough for module number four where we learned about Rag and the next step we're going to head over to start working with agents and tools and this is going to blow your mind so let's go ahead and head over to module number five hey guys so welcome to this fifth module in this Lang chain master class in this module you're going to learn everything you need to know about using agents and tools and before we dive into actually going through all the awesome code examples that I've set up for you guys what we're going to do at a super high level is go through what the heck are agents what are tools how do they relate and I will say before I like actually dove in to work with agents for the first time I thought they were going to be this super magical thing that I would never understand it was going to be super overwhelming but it really wasn't once you U now that you've gotten this far inside the master class and you have a really good understanding of prompts and you have a good understanding of chat models and so forth this isn't going to be too complex so stick around I think you guys are going to be like oh that's actually pretty easy to understand so let's dive into it what is an agent well under the hood an agent is nothing more than an llm that has been provided a specific prompt to guide Its Behavior so the best way I like to think of it is a state machine and if you've never heard of a state machine it's basically just a machine that has certain States and it can perform different actions at each state so let's just say it's at State one well at State one it can do something else and once it's done with that it goes to the next state and basically it will just perform a certain Loop of task and that's basically what a state machine is in the same way that's exactly how agents work we are creating a prompt that defines certain States and behaviors for our agent to do and what it's going to do is just flow through all of those different states and at each state perform a different action so let's walk through it in this actual diagram and we're going through it part by part so the first thing that most prompts have inside of an when they Define our agents is they usually have an action State and this action state says well this is where you can actually perform an action so think of it if we're creating a writer agent well the whole point of that agent is to write so usually we'll say our end goal is to write a bullet list about what's going on in the news today well this agent will know it needs to write a bullet list so let's just say it starts off with our input and just talks about the recent Apple event and it writes a bullet list well then what it'll go is go to the next state where it can make observations about its actions and from here what it'll do is go that was a little weird you only produced four bullet points then we'll come back down to the thought and when we are in the thought stage this is usually we'll plan out plan is the key word here we usually plan out what upcoming actions or behaviors we need to do next so in this case we'll go oh for whatever reason we only had four bullet points I need to rewrite my article or my bullet list and make sure I have five bullet points this time so let's add one more and then we'll just go back up action we'll update our bullet list and have one more so we'll hit a total of five observation phase yep we have all five bullets things look good and then now that we get back to our thought stage you know we're going to say everything looks great we look like we're done and our thought phase will go okay cool I no longer need to work as an agent here's my final answer and that's a super simplified version but really under the hood that's exactly what's happening an agent gets a specific prompt with an llm that tells it how to behave we pass in a goal and it'll just work towards that goal and just cycle through these stages and there's a bunch of different types of Agents but this is the core Loop that you'll hear about the most right here okay now what the heck is a tool why do we care about uh care about it when it comes to agents and I when doing this course at first I thought about breaking them up but I didn't just because they're pretty much useless without each other and you'll understand why in just a second so a tool is nothing more than a basically some usually some code and that provides our agents with additional functionality so basically these tools provide our agents with superpowers is the best way I like to think about them we give them upgrades is the best way I like to like kind of think of it my in my head so a few common tools that you'll hear of are tools that will allow you to search the internet so think tavali serper duck ducko there's a ton of these tools and they allow our agent to interact with the outside world cuz if you remember these llms they have constraints they're just you know U they have cut off dates and they basically you know can only think thoughts and write text and this is how we allow them to interact with the outside world so that's what the search internet tool can do from there we could also set up our agents to actually execute code so we can hook them up to an interpreter to like oh here's the python code let's go over here oh yeah you can actually now write and draw some you can you know run some code you can generate some graphs with plot Le like you can do a lot of stuff when it comes to having your agents interact with code the final one you could also have tools that allow your agents to go interact with databases so obviously R so far we've kind of like hardcoded and wired up R in the past with in our rag section to work with a vector store but you can actually set up tools to allow your agent to interact with a vector store a SQL database like there's a ton that you can do so it's just up to you to create those tools and then give those uh tools to your agents and so just give you an example if we were trying to you know find today's news find today's like top five most talked about articles and then plot them inside of a a python plotly chart for like how correlated they were something silly but basically you know we could do that with tools because going through the same Loop we would understand first I need to go off and find all the news articles and find the most talked about ones well whenever I take that action I'll search the internet come back I now have information about the outside world thought hm okay well now that I have information about the outside world I need to start mapping the information I found to a to some sort of chart where we can visualize how correlated everything is just you know Silly example but when now we come back to the action step and goes okay well I now know the five most talked about articles now I can start actually generating code to make a visualization out of this information so then I'll start executing code oh NOP it didn't work it didn't properly run go through it a few times okay great now everything's working here's all the python code so you can generate some graphics so that's exactly how it works under the hood and you're just going to keep going through this core Loop and we've now supercharged our agent with tools to go off and interact with the outside world and actually start taking some action so that's enough of everything at a high level what we're going to do in the rest of this example is I've provided about five to six different code examples that you'll see where we're actually like code everything up that we just talked about so enough talking let's go ahead and dive into our first example so you can see all this in action all right guys so welcome to the first example inside of the agent and Tool module now what we're going to do inside of this example is just walk through everything at a super high level because this is going to be the first time we're going to be introducing agents and tools inside of actual code so we're going to go through it super slowly and then after that we go through this example we're going to later do a deep dive into agents so you can understand all the different ways we can use them and then we're going to do a deeper dive into tools so you can learn learn how to use existing tools and learn how to create your own so that's what we're about to do let's go ahead and dive into this part by part so you guys can Master agents and tools all right so some of this is going to be super similar to start off we're going to be loading our environment variables because we need to use open AI now the first thing that we're going to do in here is go off and create a tool and for this one we're just going to create a super simple tool that allows us to access the current date and time for our local computer CU if you think about it our llms you they were generated in the past they have constraints of and cut off dates and they actually have no way of knowing what time it is currently so whenever we're actually using these llms in Agent form we can add a tool time so that our agents can access our current time this is going to be super helpful as you go off to build larger and larger agents where they need to interact so this is just a super basic one so let's walk through what's happening so the first thing is we're going to create just a regular function that all it does is it reports date time because date time is just a standard library and we're just going to grab this the current time and then we're going to return the current time in this format to where it's hour minute minute so that's all we're trying to do and that's the whole purpose on this function we'll dive later into why had to set up our parameters like this for the function but we'll come back to that later all right cool well now once we have defined our specific function that we want to do we have to wrap it inside of a tool and later we'll get into actually like using existing tools but for right now this is just like how you can make your own simple tool with your own code but basically all you do is you call the tool class which comes from up here blank chain core tools that's how we can create a tool and it's just up to you to give your tool a name a descriptive name about like you know what does this tool do that way whenever the agent's executing and it's like oh I need to solve a Time problem oh it makes sense for me to use the tool that talks about time so that's why it's super important for us to give the name and description to be very representative of what what going to happen under the hood from there we pass in the function that we want the tool to perform whenever it gets called on so in this case whenever we say like hey give me the time under the hood it's going to trigger this function which is going to return our string representation of the current time okay so that's how we make a tool that's how we add it to our tools list and once we eventually have our tools list we can actually pass this over to our agents and you'll see that here in just a little bit okay so now we've got tools out of the way at a super basic level now we're going to work on creating our agents so if you look at this you might be like what the heck are we doing what are we what are we pulling what is this word react well uh react stands for reason and action and all we're doing here is we are pulling out a prompt because you remember from earlier earlier from prompt templates all we're doing is pulling out a prompt template that tells our llm how to act so if you actually go and read what this uh what's going to happen at this prompt you'll head over to to a website like this I'll actually copy the link for you guys so you can read it yourselves but you can see kind of how we talked about earlier an agent's nothing more than an lolm with a super specific prompt telling it how to behave so this is exactly what's happening under the hood this prompt template that we're going to create an agent around you know it's just like hey answer the following the best you can here's the tools you have access to and then that Loop that we kind of talked about earlier where you're taking action you're making observations planning out thoughts and providing a fin answer this is exactly what you know what this prompt template is telling you to do so you know hey use the following format to basically perform actions so you know taking the input think about it take action here's the you know like as we're working with tools sometimes when whenever we're taking an action like get time well sometimes we might have to pass it in parameters to our functions so like I want to get the time in Tokyo I want to get the weather in San Francisco so that's what actions like you know use the tool and then action input is like whatever parameters we want to pass over to it so just hope hopefully that makes sense observation hey look at the results of the action thought you know go go off and here's what I need to do next basically plan yeah so and you can kind of see we're telling our llm to repeat this over and over and over until we get a final answer okay so that's what's happening under the hood and we're actually able to like the part that's nice is it's kind of like GitHub where we're able to just pull down and reuse other people's code that's working but in this case we're just pulling down other people's prompts which is pretty cool if you think about it okay so now that we have our prompt which is going to tell our llm how to act we need to keep chugging along and we actually need to specify which llm we want to create our agent around and this time we're just going to use cat gbt 40 that's the latest open AI model that's out at the time of this recording and then from there what we're going to do is go off and actually use the agent we've defined we're going to pass in the prompt that we fine and we're also going to pass in all the tools we've set up to actually go off and create our agent so if you look under the hood what's actually happening is this create react agent it's coming from the the Lang chain agents repo so I'll just scroll up to the top so you guys can see it yeah this is coming all from Lang chain agents and we're really just importing these two classes to create our agents and run them but the main thing for our agents is we're sticking to that react part to where we are going to you know reason about what we want to do take action and just continue that cycle over and over in order to actually achieve our goals so this is kind of what what it looks like under the hood if you want to actually dive in here and read more about what's going on but really we're just combining all the ingredients of everything that's needed to make an agent and just putting it into one one class so that we can actually start passing information to it and running our agent and that's exactly what we're going to do next once we have our agent it's up to us to then pass in everything over to an agent executor so an agent executor is just basically going to help manage the Run of an agent as it goes off to solve problems so if you come over here you can see an agent executor we're just going to say like hey this is allowing us to use tools and and if you actually dive into the code here too you can see this is where we're going to be like actually performing The Run and accessing the tools putting information back and forth and and continuing to go from there but really don't need to like dive into it the main thing is just understand that like yes whenever I want to run my agent I need to use an agent executor Okay cool so once we have our agent executor set up what we can do is once again use our magical word when it comes to Lang chain and we need to invoke our agent executor to start actually spinning everything up and what you'll notice is instead of just passing in a string we're passing in a dictionary and the keyword in our dictionary is input this is the main thing that our agents expect to read is an input so in our case what time is it is the question that our agents are going to be answering so enough of that what we're going to do is let's go ahead and run it so you can see all of this happen in real time so let's open up our terminal and we're going to run python this is the fifth module because we're learning about agents and tools and this is the first example so let's go ahead and run it and see what happens so what it's going to do as you go off and actually use agents you'll see a lot of colorcoded text usually coming out of the output as it's going through that reasoning taking action and making observations so you'll usually see things like purple green and white and this is is uh anytime the agents's performing an action you can see like all right what's the action I want to perform Let Me zoom in for you guys so what's the action I want to perform I went to get the time so that's pretty cool that it was able to look through all the available tools that it had and pick the correct one and then what it did next is it passed in an action input and because we didn't specify any parameters for AR tools it just gave in none but you'll notice sometimes when you're creating tools and we'll dive into this here in a little bit if you do not have any parameters for your function sometimes they'll mess up so we just accept all parameters for arguments and keyword arguments but we just don't do anything with them so that's just a quick work around but what's cool is once we you know perform the action pass in the action input you can see here in blue we get the local time back for when I'm recording right now and then now that we have that answer from our tool the agent goes I now know the final answer and once it knows it's the final answer because if you actually come back over here the thought is I know I now know the final answer it then gives us back the final answer so then that's super cool cuz you can see right here it said the current time is 8:31 p.m. so that's the agent thinking and then finally under the hood I've said that 100 times right now but what's happening is it finally now that it has the answer it generates a object that it returns back to us and you can see this object contains nothing more than the original input plus the output of the final answer from this agent so that's what's happening and what we're going to do next is um and I hope you guys first off I hope you think that is aome awesome because it's very cool that we can have agents reason and take action in the world and uh you know everything we're going to do from here we're only going to add in more complexity and show off cooler features just so that you guys can match uh Master agents and tools and just to dive in what we're going to do next like I said we have two different folders for you guys to go over all the different ways that we can use agents and tools and the first one we're going to do is we're going to do a deeper dive into agents so that you can understand different ways that we can like figure these agents to work and eventually we're going to hop over to showing you how to use more custom tools so let's go ahead and head over to our first agent Deep dive example and start looking at react chat hey guys so welcome to the second example in this agent and tools module and in this example we're going to go a little bit deeper into working with different types of agents and really expanding what they're capable of doing so in this example we're actually going to focus on swapping up the underlying prompt that we're using in the agent sprinkle a few more tools and then kind of add some chat capabilities to it so that our agents can now go off and do some internet searching for us and give us answers so let's go ahead and dive into this example so you can U understand what's going on okay so to start we're going to do the exact same thing we did last time but we're going to add in some more tools so this time we're going to do another get current time tool exact same thing and then next we're going to add in the search Wikipedia tool and this this is really just a function to go off and use the Wikipedia library and what it's going to do is basically get a summary about whatever topic we're interested in so we get ask a questions about famous people events times and Wikipedia is going to give us back a quick summary you know two sentences of information it has on that topic okay so now that we've defined those functions we now need to package them into our tools list so and we need to format everything to be in the proper tool class so that's where we're going to set up the name a description so that our agent can go oh yeah that's the tool I want to use and then the actual underlying functionality we want to trigger cool so now that we have our tools defined for our agents we can now move over to actually creating our agent and what you'll notice in this example is we're using a different type of agent this time for our prompt excuse me so last time we were just using the react agent but this time we're using the structur chat agent so what this prompt is focused on it's actually having a chat so if we head over to uh over here where we actually can see the underly prompt template it looks a lot different than the last one so you can see like hey you're responding to a human with helpful information you have access to the tools in our tools list and I need you to basically create a a Json blob for these tools to go off and perform actions that's enough of that and then what's going to happen next is like all right cool here's you're going to search for a question go off and basically have thoughts about it take action so this is where we're going to use that Json blob and this is basically going to be like you know information from the past that we've taken like so whenever we get a response back we're going to save everything as a Jason blob and I'll keep it at that but the main thing is it's going to allow us to have a conversation with our agents and it's going to go off and you know use tools to perform actions on our behalf okay so that's what's happening under the hood now what are we going to do next per usual we're going to uh spin up a chat model I'll actually go ahead and make sure we're using the right model so we're going to GPT 40 make sure using the latest one and then from there what we're going to do is we're going to use this new we haven't used it before but it's called a conversation buffer memory all it does is it allows us to store our chat history in in memory that's all that's happening so in the past we've done things such as you know we'll just do like chat history and we'll save it to a list well this is just a more and you know we'll always add in our system messages and human messages well this conversation buffer memory it just it does a better job of doing it so uh we're just going to use it for this one it makes things simpler to set up for us okay well now that we have everything initialized let's start combining things to go off and create our agents so that we can start running them so per usual we're going to create our agent and we're going to pass in the main ingredients which are going to be our prompt our tools that we defined in the specific llm we want to use in the underlying agent and then from there what we can do is create our agent executor and this is going to be you can see we're adding in more tools to our agent executor this time these are the same as last time our agents and tools but now we're going to add in memory to our agent executor and this is how we're going to keep track of our previous responses and messages with our agent because we're going to be talking to this one and what you can see from here is we're now going to now that we have our agent executor been up and it's ready to run what we're going to do is start go ahead and start our chat conversation with the user so in our case we're going to start chatting with our agent so this is going to look exactly like our initial chat example we did except now we've supercharged it with an agent that's not just talking to a vector store it's going off and searching the internet for us to get responses so this is super cool and I hope you guys can see the value of it so let's go ahead and hop down here and start running our agent and actually seeing how it works so I'm going to make this a lot bigger because you'll see how cool it is cuz it's going to actually show us behind the scene what the agent is thinking and before I trigger it I do want to show you guys one thing let's go ahead and get the code ready so agent Deep dive and this is example number one the thing that per usual we're going to use the magic word when it comes to running Lang chain tools so the agent executor and per usual we do have to pass in the input and you'll notice as you use these agents tools a lot more everything's kind of structured as an input and an output so that's how we can show the response from the AI we're just going to say yep grab the output and per usual when the user submits a message we're going to add a human message and whenever the AI generates a message we're going to add an AI message okay let's go ahead and run it so you can see what's happening under the hood so we're going to start off asking a question we're just going to say who is George Washington and this will go off and use Wikipedia so that's cool it found the proper tool to use and as you can see it passed in the action input of like well who are we trying to query about and it's so cool that the AI went from a question like who is George Washington to picking out the core topic of that question and then passed it as the action input so it's amazing that this AI can figure out based on what parameters we need to pass in yeah just grab the core part of it so that's super cool now in the yellow we're actually getting back a response from our tool so our tool from Wikipedia says you know like hey here's everything you need to know about him and so forth and so forth and then once we have the final answer it generates a response to us so you can see the bot came back and said yep give us everything that Wikipedia said so uh let's see we can actually ask because this is a conversation we can add to our original question so how old was he when he died so because this is a conversation we can actually refer to our previous messages so in this case it didn't even have to go off to Wikipedia this time because it was like oh wait already know the information so I can just use use that to respond and we can ask other things such as who is Elon mus and how old is he right now so this question is a little bit more interesting because it's a two-part question first you have to go off and figure out who is the main person that we're talking about so in this case it's Elon Musk for whatever reason it's kind of struggling right now to to find out who he is but usually this is just the part of Agents where it's just going to go in a loop until it finally gets an answer for whatever reason it couldn't figure out that one so we'll just ask a different question because I do want to show you guys the key key underlying part who is Steve Jobs and how old was he when he died and the main reason I'm doing these two-part questions is because I want to show you guys how these agents can understand what we're trying to do yeah and for some reason I think Wikipedia is just crapping out on me but the main thing to know is what would happen under the hood normally is these agents would go off and find the result for the first part which is who is Steve Jobs and once it knows the answer it would then go off and actually find a you know using the response it would then trigger the next part and the question so you can see like yep he's an American entrepreneur obviously known for founding apple and he died at the age of 56 so that's that's very cool that I can do a two-part question and you can even go deeper to where it triggers off a second Wikipedia call but I'm not going to go into that for this example so I hope you guys are like wow these agents are powerful they can act on my behalf and go you know find information inform for me and I can just talk to them so I hope you find that super cool and what we're going to do next is dive into the next agent example that I've set up for you guys where you can actually talk to a document store so we're going to work on this one now hey guys so welcome to the third example in this agents and tools module in this example we're going to be diving into how we can connect our agents up to a vector store so that they can kind of work together to answer questions about our data so that's exactly what we're going to be setting up in this example so let's go ahead and dive in and what you'll notice is a lot of the information that I'm going to be showing in this module was built off of everything that we've kind of done in module 4 with Rag and all the previous modules before that so the log this is going to look super familiar so I'm not going to dive super deep into it but to start off we are going to be setting up all of our file path directories so we can point to our Vector store so this is the same Vector store that we did earlier that read all those different books for us so we're going to go off from there set up our embedding so that we can actually you know uh whenever we ask a question it we can embed it and compare it to all of our other documents to you know grab the most similar answers so we're going to then spin up our Vector store with our Vector database and the specific embedding function we want to use and then we're going to use the exact same retriever that we used the entire time in the past we're just going to use the similarity one this time which is just going to grab the most similar results not worry about a threshold and in this case we're going to grab the three top results and if you remember we used a 1,000 tokens per result uh per document so this is going to give us 3,000 tokens worth of information for our agent to use all right let's keep chugging along from here we're going to start working on creating our agents or sorry llm so in this case we're just going to use Chad gbt 4.0 and then now we're going to be kind of combining two different examples so in the past we had an example where you could ask specific questions about the doc store to the vector store that we've set up and but now we're going to be combining it with our agents so this is the exact same demo we did before where we kind of first set up like you know just like contextual what we're doing here in the first place so like hey you are working with chat history to solve an answer that's all you're doing and the second part was the history aware retriever so this is like hey go look at the previous questions that we've worked with plus you can look at the uh you can use the retriever to go off and answer or grab information from our Vector store so this is definitely going to go a little in the weeds but we already covered this in detail in our previous rag example right here where we did rag conversation so you've already done this in the past we're just now building on top of it okay cool per usual we we're just going off and creating stuff from our document chain this is how we can actually if you go under the hood this is how you can go about passing a list of documents over to a model so that they can be processed once we' set up all that we can set up our retrieval chain which will basically be able to interact with our Vector store okay enough of talking about setting up our Vector store now it's time for us to go off and set up our agent so we can have our agent communicate with our Vector store on on our behalf and perform actions and and lookups information so in this one what we're going to do is we are going to use the same react agent that we did in the first time which is just going to it's going to think about stuff take action make observations and just keep performing that in a loop and per usual when we're working with agents we have to set up a tool well this time we're going to set up a Custom Tool and what's interesting is under the hood this tool is going to do is it's actually going to invoke our rag chain so what's very cool is now anytime our agent has a problem where it needs to answer a question what it's going to do is it's going to go well I don't know the answer to that question but you know what I bet this tool does because it's useful for whenever you need to answer questions about the context of whatever the question is so what's cool is all we're going to do here is this we're going to invoke this rag chain and what we're going to do to it is we're going to pass in the input so it's going to be the person's question but we're also going to pass in the chat history so that we can have some uh contextual awareness of previous messages so that's super cool so now that we have made a new tool for our agent we're going to go through the normal process of setting up and creating our agents so that we can actually start running them so now that we have all of our agents set up with a proper tooling we can now go into another while loop and in this while loop we're going to once again start chatting to our agent so I'm going to come down here we're going to clear things up and now we're going to actually start running this example so you can see it in action so we're going to do python this is the agents and tools module we're working inside of the agent deep dive and we're going to start using the react doc store so let's go ahead and run this one and you can see so we can start asking questions and what's nice already at the gate we are you know accessing the vector store so because there was that one file I set up where I talked about Lang chain that's the first question I'm going to ask so how can I learn more about Lang chain so what it's going to do is it's going to well this is a question I need to get an answer about and then what it's going to do is actually trigger the AI to go off and get that information and what's cool is like it responded with the exact part of like yeah this is you know to learn more about Lang chain that what the document said was like yeah go watch Brandon's YouTube channel here's a link to the YouTube channel so as you can see that's pretty freaking cool and then you can follow up because it is a conversation so you can say who is Brandon and then it'll it'll go off and actually you know say oh he has a YouTube channel where he talks about like AI does not mention the name Brandon oh I guess I should have capitalized it so so yeah that's how it works at a super high level when it comes to working with the dock store this example was a little weird but I just wanted to show it to you guys just so you can understand like oh yeah you can use you can really start connect these agents with different basically different tools and use these agents in different ways and I would do want to show you guys real fast when it does come to the agent Deep dive I do want to show you whenever we set everything to verbose verbose normally yeah so here in the agents and tools I just want to show you guys when this is actually going off and grabbing the information so we'll do this here for both and I'm going to rerun this example just so you guys can see that it is it's actually grabbing from the doc store because I I like to see the agent think that's one of my favorite things so whenever we run this again we'll now do python fifth module fifth module agent Deep dive example number two we're going to run it I'm going to ask who is branded again so um or how do I learn more about L chain how do I learn more about Lang chain and then now you can see it's actually whenever it's running you can see that it's saying like Okay I need to answer a question about I need to to answer a question because I have no idea what is Lang chain in the context of what I'm learning about okay cool well I'm going to call the answer question tool the input I'm going to pass in is how do I learn more about Lang chain and then so you can see cuz we passed in an input coming back down here to our code yeah so here's our input the query is now the same as this query the chat history this was our first question so it's not updating it yet and then the context well this is all the information that we get back from our Vector store so this is some information from our Vector store some of it looks like it is yeah this is all documents from our Vector store and once it has those 3,000 tokens worth of information and then converts that into a final answer that it then spits back to us that we can talk to here so yeah I hope you guys I think that's super cool to see how the agent's thinking and operating you know whenever it's in verbos mode but enough of doing the agent Deep dive what we're going to do from here is we're going to head over and start going deeper into different ways that you can create your tools so that you guys can Master this and create your own tools and really supercharge your agents so let's go ahead and head into that next hey guys so welcome to the third example inside of the agents and tools module and in this example I'm going to show you guys the most basic way we can go about creating tools and that's going to be using the tool Constructor and you've already done this a few times but now we're just going to go into a deeper dive of understanding like oh that's actually what's going on and here's how I can start making tools so what I want to do is to start off I just want to show you the three functions that we're going to try and add to our tool set so the first one is just going to be greet User it's going to take in a name and then it's just going to come back and say like hello we're going to do reverse string all this is going to do is it's going to take in some text and reverse it and split it back and then finally we're going to set up a concatenate strings tool that just takes in two strings and concatenates them together and spits out a string so well obviously you know that's just regular python let's dive into the tool section where we're going to start using the tool Constructor so this is exactly what we've done so far whenever we've created tools in the past where we've kind of set up a name set up a description and then Define the specific function that we want to call but the main thing I want what to bring your focus to whenever we're using the tool Constructor is this is a great way to go about creating simple tools because all we're doing is just saying like here's the name here's the description and then we're just passing it a function we're not specifying anywhere the like oh yeah this takes in two parameters one's an one's a string one's one's a number like we're just relying 100% on the llm underneath to understand what the tool needs and provide it to it so and most of the time that actually works really well and that's whenever you just have a simple tool this is the best way to go about it it's super simple to do and the part that I did want to show you guys as well is if you're not using this complete basic way to create a tool you can go off and use something called the structure tool and the structure tool is great whenever you want to kind of set up more complex functions so like this one takes in two parameters so you know if you're doing anything that takes in more than one parameter I would recommend going with a structured tool and the part that makes this different different is it takes in all the same information as before except then now it takes in this schema and this schema just we're just going to use pedantic which is just a great way to like define basically like typed models um so we're just going to say like hey here are our arguments for concatenating string I expect to have two two properties A and B where a is the first string and B is the second string so we're clearly defining oh wow whenever I pass in I need to basically give two strings and that's how it's going to how it's going to work so now that you've kind of seen how this works I'm going to go ahead and actually trigger this to run and so you can actually see all these tools working in action and the only thing I do want to mention that we haven't shown so far is uh I am using a new prompt for this one it's called open aai tools agent and what this one is doing is it's going to it's basically just focused more on using tools so you can kind of see you're a helpful assistant here's your chat history here's your human inputs so this one all it does really is it's just yeah it kind of just it works really well whenever you're trying to use tools and so what we're going to do is go ahead and Trigger this and what we're expecting to see back is three different responses one we're going to tell the agent executor to greet Alice so greet is going to hopefully trigger our first tool then eventually we're going to say reverse the string hello and then we're going to say concatenate and we're expecting our agent to go up and use the appropriate tools to make this happen and we're going to log the entire process okay so what we're going to do come down here clear things up and we're going to run our example so we're going to do Python and this is the fifth module this is a tool Deep dive and we're going to look at our first example together so like I said under the hood this is going to go off and Trigger each one of these so let's look and see how it did so for the first one we said hey we're trying to greet Alice so you can see that it said I need to you know invoke greeting user with the keyword Alicia or Alice and what it's going to do is come back with an answer because if you come back to our original function all it was supposed to do is pass in hello and the person's name and that's exactly what it did so thumbs up for the first one the next one is reversing the string so you can see that like yep we're invoking reverse string with hello it did it it performed the code and now we print it back and then finally what we're going to do for the last one is concatenate strings so you can see I need to invoke concatenate strings and it did a really good job of creating a dictionary where it specified what is a and what is B and this all comes back to the fact that we set up our structur tool and we passed in an argument schema that was the magic that allowed this to happen and now you can see that it did a great job of splitting it uh concatenating it together okay cool so that was hopefully a quick Deep dive into creating tools and now we're going to go into the next module where we're going to start learning how you can use the tool decorator to kind of simplify some of this so let's go ahead and start working on example number two in the tool deep dive right now hey guys so welcome to the third and final example in the tool Deep dive and in this example you're going to learn how to create tools but you're going to learn how to do it where you have the maximum control over how these tools behave and what we're going to do in this module is we're going to set up two tools the first one is going to be a simple Search tool where we're going to go off and use Tavi to search the internet and the next one is just going to be a multiply numbers tool just a super super basic one so that's what we're going to be doing in this example and I just want to walk you through the major parts together real fast cuz some of this is pretty similar so the first thing that we're going to be doing is setting up our pedantic models and this is what we're going to be doing to define the specific inputs for both of our tools so this is nothing new you've seen this so far all right now let's actually dive into the part where we're going to create our tools and how we have maximum control over them so the main way we're going to be creating our tools is by using the base tool class now hop over to the L chain doc so you can kind of see it so the main way it works is we're going to be using the subass base tool to generate new tools so we're going to inherit from based tools to create new classes that are tools basically so what you can see as Lang chain says like hey this is the way you can have Maxum control over your tools but you know it takes a little bit more work and the part that's interesting is you can kind of see like we are basically using this example I just want to like walk you through the setup of it but the part that's nice is you can actually set up your tools to have different functionality so you can set up a tool to have a run so you can see this is a private run method and what you can see is we can actually say hey here's what you need to do here's your inputs don't worry about run manager I've never really found it helpful and then you can Define the output and what's super cool is you can actually if you wanted to go even harder you could actually Define the output as a pedantic model and if it fails during the run to generate the proper response it'll redo it so this is a really cool way if you plan on doing doing you know spitting out some Json or you know you want to make sure that you print out an object that for sure has a like a person's contact info so it for sure had to have the person's first name last name and email you could set up a pedantic model as the output and you can do that all here inside of your custom tools when you're inheriting from base tool and then finally you can set up things to run synchronously or you can set them up to run asynchronously we're just going to stick to synchronously for this example okay so let's hop back over to our example so the first thing that we're going to be doing is setting up a Search tool because we want our agent to go off and access the internet well what we're going to do is we are going to do exactly kind of what we did in the tool Constructor where we have to give our tool a name because we need to let our AI know like Yep this is the name of the tool and here's when I would need to use it whenever I need to answer questions about current events so you know anything that's not inside of the ai's knowledge base and then finally what is the argument schema well this is exactly what I want to be passed in the simple search input which just contains a query okay now whenever this tool gets triggered and calls underlying run method what's going to happen is we expect to get that query of a string of what we need to go search now here's where things get interesting this is where we've kind of defined what this function should do so in our case we're going to use Tav and if you head over to their documents this is how you can connect your llms to the web and it just makes it super simple to go off and search the internet uh and then just I'm sure some of you guys are curious how much it cost it's free every month for 1,000 calls and then it goes from up from there but no I've I've used them and I've really liked them so far so definitely recommend checking them out and to get started it's super simple you're going to basically just make sure you have access to this class you're going to set up an account so you get API key and then once you have an API key you can just start using their client and making request and that's exactly what we're doing in rcode we're importing that client that we would have installed I've already added to the uh Tomo file so it's already going to work for you guys now we're going to and then once you have have your environment variable set up and grab it you're just going to make sure you paste it in here and once you've done that you can now actually start using the client to make requests to the Internet so let's go ahead and we're going to run through the second tool real fast and then we're going to run it so you can see that like wow we are actually communicating with the internet and it's super cool all right and the final one this is just a super simple example I just wanted to show you guys like yeah you can create a tool to multiply numbers this one's super simple I just wanted to to add it in here for you guys but once you created your two tools what you need to do is you need to go off and basically in your tools list we're going to create two new tools so as you can see each one of these is a class so to create a new instance of the class we're just kind of come down here and just you know create them down here so once we have two instances of these classes we're going to do the normal thing with our agents set up the llm we want to use give it the prompt to guide its instructions set up our tool calling agent um this one is a little bit different from what we've done in the past in the past we've been doing the the react agent so the tool calling agent it just specializes in using tools so that's what it's kind of doing and then finally what we're going to do is once we have our agent set up we're going to use the agent executor to actually start uh handling our runs all right so let's go ahead and run our agent with these two different examples the first example we're going to be using is search for Apple intelligence and I'm going to take off these quotes just so we have to make our uh AI learn a little bit more about Apple intelligence and then finally we're just going to pass in a sentence and we expect this sentence to get converted over to numbers that you can see specifically floats that we can then start to use to to to multiply so that's what we I expect to see happen whenever we run this so let's go ahead and run it real fast so this is in the agent module and we are in the tools section and this is the final one let's go ahead and run it so we can see the search results and look at just the math so you can see out the gate what it did is it said all right I need to do a simple surge because that was the name of our tool let's go back up here a simple surge and we just want to what is the query of what we want to look up oh we want to look up Apple intelligence so it pulled out the key topic and then Tav our Search tool came back to us and said well here's your query here's the what you want to look up and then it gave us back the results so it went off and searched the internet in a way to where we get quick titles URLs so if we wanted to we can go off and actually explore some of these URLs and dive deeper but you can see it came back to us with some more information about each each of these things and today is is the middle of June so you can see this is grabbing all recent information about what's happening with the new Apple intelligence release okay cool and then once it gave us back the actual like this is the raw score and actually you can see it here here's some of the relevant information so just putting it in a nice format for us um that's what's happening with the tool and once it has that information um it's just going to spit out the final response for us so you can kind of see it all right here this is the final response and the outputs right here it just going to look exactly this is basically the output if you printed it out that's what you would see uh um that you you were to pass it out to your user okay and enough of that the tool went super simple the reason why I kind of like this example is because usually tools struggle with like if you just to run this as a regular tool decorator for whatever reason it kind of struggles to recognize like oh yeah that's a float so I just thought this was a cool example of like oh yeah we have to convert a string to a numerical representation so yeah and we get back to the correct answer and it's a float which is what we want okay all right so that's it for the tool example and this is actually it for the entire uh agent and Tool Deep dive just to like plant some seeds in your brains of like what else is possible crew AI is by far one of my favorite pack uh products out there when it comes to working with agents because they make it super cool for us to actually set up agents to work with other agents so right now we have one agent you know performing a task but what happens if you had like a writer agent collaborating with a researcher agent who each specialized like the uh if the if the researcher agent specialized in exploring the web and the writer uh specialized in writing articles that were had a good Rhythm used proper like languaging to write interesting articles well these guys could work together to generate an awesome report so that's just scratching the service of what cre I can do but I just wanted to like plant some seeds for like what's next after you guys learn like how to make an individual agent well multi-agents tools are the next and I definitely recommend creai and I have a ton of videos on crei inside of my YouTube channel so I definitely recommend and checking that out next but yeah that's it for the fifth module so let's go ahead and wrap things up hey guys so I hope you guys have enjoyed this Lang chain master class we covered a ton of information in all five of the different modules hopefully you guys are now Pros when it comes to working with chat models prompt templates chains Rag and your agents and tools and just as a recap all the source code in this video is completely for free there's a link down the description below while you're down there it would mean a lot to me if y'all can hit that like And subscribe especially if you've made it this far in in this video also there's that free school Community where you can meet like-minded AI developers and we have those weekly free coaching calls so you'll definitely want to take advantage of that and then outside of that I have a ton of other AI related content on my YouTube channel everything from Full stack AI tutorials all the way to like crew AI Deep dive so you're definitely going want check out one of those after this video but enough of that I hope you guys have a great day and I can't wait to see youall around in the next one see you